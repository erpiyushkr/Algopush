<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>
    LeetCode 2799: Count Complete Subarrays | Algopush
  </title>
  <meta name="description"
    content="Learn step-by-step solutions to LeetCode 2799 using brute force and sliding window in C++, Java, and Python. Master counting complete subarrays easily." />
  <meta name="keywords"
    content="leetcode, leetcode problem of the day, leetcode contest question, leetcode easy question, leetcode medium question, leetcode daily question, LeetCode 2799, Count Complete Subarrays, Sliding Window technique, Array problems, Coding interview prep, Algorithm optimization, C++ Java Python solutions, Time complexity, Algopush tutorials" />
  <meta name="author" content="Algopush" />
  <meta property="og:title" content="LeetCode 2799 Solution | Count Complete Subarrays in an Array" />
  <meta property="og:description"
    content="Complete guide to solving LeetCode 2799 with brute force and optimized sliding window approaches with code examples." />
  <meta property="og:image" content="https://algopush.com/Leetcode/Images/2799.png" />
  <meta property="og:url" content="https://algopush.com/Leetcode/2799-count-complete-subarrays-in-an-array.html" />
  <meta property="og:type" content="article" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="LeetCode 2799 Solution | Count Complete Subarrays in an Array" />
  <meta name="twitter:description"
    content="Multiple approaches to solve LeetCode 2799 with detailed explanations and code implementations." />
  <meta name="twitter:image" content="https://algopush.com/Leetcode/Images/2799.png" />
  <meta name="rating" content="general" />
  <meta http-equiv="content-language" content="en" />
  <meta name="distribution" content="global" />
  <meta name="robots" content="index, follow" />
  <link rel="canonical" href="https://algopush.com/Leetcode/2799-count-complete-subarrays-in-an-array.html" />

  <!-- Favicon -->
  <link rel="icon" href="../components/favicon.png" type="image/x-icon">
  <link rel="apple-touch-icon" href="../components/favicon.png">

  <!-- Preload important resources -->
  <link rel="preload" href="../script.js" as="script" />
  <link rel="preload" href="https://algopush.com/styles.css" as="style" />

  <!-- Structured Data for enhanced SEO -->
  <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "TechArticle",
        "headline": "LeetCode 2799 Solution: Count Complete Subarrays in an Array",
        "author": {
          "@type": "Organization",
          "name": "Algopush",
          "url": "https://algopush.com"
        },
        "image": "https://algopush.com/Leetcode/Images/2799.png",
        "datePublished": "2025-05-03",
        "dateModified": "2025-05-03",
        "publisher": {
          "@type": "Organization",
          "name": "Algopush",
          "logo": {
            "@type": "ImageObject",
            "url": "https://algopush.com/components/logo.png"
          }
        },
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://algopush.com/Leetcode/2799-count-complete-subarrays-in-an-array.html"
        },
        "speakable": {
          "@type": "SpeakableSpecification",
          "xPath": [
            "/html/head/title"
          ],
          "cssSelector": ["h1", "main p:first-of-type"]
        }
      }
    </script>

  <script>
    // Function to handle tab switching
    function openTab(evt, tabName) {
      // Get all elements with class="tab-content" and hide them
      const tabContents = document.getElementsByClassName("tab-content");
      for (let i = 0; i < tabContents.length; i++) {
        tabContents[i].classList.remove("active");
      }

      // Get all elements with class="tab-button" and remove the "active" class
      const tabButtons = document.getElementsByClassName("tab-button");
      for (let i = 0; i < tabButtons.length; i++) {
        tabButtons[i].classList.remove("active");
      }

      // Show the current tab and add the "active" class to the button that opened the tab
      document.getElementById(tabName).classList.add("active");
      evt.currentTarget.classList.add("active");
    }

    // Initialize the first tab as active by default
    document.addEventListener("DOMContentLoaded", function () {
      const defaultTab = document.querySelector(".tab-button");
      if (defaultTab) {
        defaultTab.click();
      }

      // Load header and footer
      fetch("../components/header.html")
        .then((response) => response.text())
        .then((data) => {
          document.getElementById("header").innerHTML = data;
        });

      fetch("../components/footer.html")
        .then((response) => response.text())
        .then((data) => {
          document.getElementById("footer").innerHTML = data;
        });
    });
  </script>

  <style>
    :root {
      --primary-color: #102c41;
      --secondary-color: #196391;
      --accent-color: #102c41;
      --light-bg: #f5f9fc;
      --highlight-color: #f5f9fc;
      --text-color: black;
      --light-text: #7f8c8d;
      --border-radius: 6px;
      --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --transition: all 0.3s ease;
      --meta-color: #db5305;
    }

    /* Base Styles */
    body {
      margin: 0;
      padding: 0;
      font-family: "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans",
        "Helvetica Neue", sans-serif;
      background-color: var(--light-bg);
      color: var(--text-color);
      line-height: 1.7;
      font-size: 1.05rem;
    }

    /* Main Content Container */
    main {
      max-width: 920px;
      margin: 2rem auto;
      padding: 2rem;
      background: #fff;
      box-shadow: var(--box-shadow);
      border-radius: var(--border-radius);
    }

    /* Problem Visualization Image */
    .problem-visual {
      max-width: 100%;
      margin: 1.5rem 0;
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: var(--box-shadow);
      text-align: center;
    }

    .problem-visual img {
      max-width: 100%;
      height: auto;
      max-height: 400px;
      display: inline-block;
    }

    /* Typography */
    h1,
    h2,
    h3,
    h4 {
      color: var(--primary-color);
      font-weight: 600;
      margin-top: 1.8rem;
      margin-bottom: 1rem;
      line-height: 1.3;
    }

    h1 {
      font-size: 2.2rem;
      border-bottom: 2px solid var(--primary-color);
      padding-bottom: 0.5rem;
    }

    h2 {
      font-size: 1.7rem;
      border-left: 4px solid var(--accent-color);
      padding-left: 0.8rem;
    }

    h3 {
      font-size: 1.4rem;
      color: var(--secondary-color);
    }

    a {
      color: var(--accent-color);
      text-decoration: none;
      transition: var(--transition);
    }

    a:hover {
      color: var(--primary-color);
      text-decoration: underline;
    }

    /* Code Blocks */
    pre {
      background: #f8f9fa;
      padding: 1.2rem;
      border-radius: var(--border-radius);
      overflow-x: auto;
      border-left: 4px solid var(--accent-color);
      font-size: 0.95rem;
      line-height: 1.5;
    }

    code {
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      color: #24292e;
    }

    .token.comment,
    .token.prolog,
    .token.doctype,
    .token.cdata {
      color: #6a737d;
    }

    .token.punctuation {
      color: #24292e;
    }

    .token.property,
    .token.tag,
    .token.boolean,
    .token.number,
    .token.constant,
    .token.symbol,
    .token.deleted {
      color: #d63384;
    }

    .token.selector,
    .token.attr-name,
    .token.string,
    .token.char,
    .token.builtin,
    .token.inserted {
      color: #22863a;
    }

    .token.operator,
    .token.entity,
    .token.url,
    .language-css .token.string,
    .style .token.string {
      color: #d63384;
    }

    .token.atrule,
    .token.attr-value,
    .token.keyword {
      color: #d63384;
    }

    .token.function,
    .token.class-name {
      color: #6f42c1;
    }

    .token.regex,
    .token.important,
    .token.variable {
      color: #e36209;
    }

    .highlight {
      background: var(--highlight-color);
      padding: 1rem;
      border-radius: var(--border-radius);
      margin: 1.5rem 0;
    }

    /* Tables */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1.5rem 0;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    th,
    td {
      padding: 0.8rem;
      text-align: center;
      border: 1px solid #ddd;
    }

    th {
      background-color: var(--primary-color);
      color: white;
      font-weight: 500;
    }

    tr:nth-child(even) {
      background-color: #f2f2f2;
    }

    /* Tabs */
    .code-tabs {
      margin: 0.5rem 0;
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: var(--box-shadow);
    }

    .tab-buttons {
      display: flex;
      background: #eaecee;
      border-bottom: 1px solid #ddd;
    }

    .tab-button {
      padding: 0.7rem 1.2rem;
      background: transparent;
      border: none;
      cursor: pointer;
      font-weight: 500;
      color: var(--text-color);
      transition: var(--transition);
    }

    .tab-button.active {
      background: var(--primary-color);
      color: white;
    }

    .tab-button:hover:not(.active) {
      background: #d5dbdb;
    }

    .tab-content {
      display: none;
      background: white;
    }

    .tab-content.active {
      display: block;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    /* FAQ Section */
    .faq-section {
      margin: 2rem 0;
    }

    .faq-section details {
      margin: 0.8rem 0;
      padding: 0.1rem;
      border: 1px solid #ddd;
      border-radius: var(--border-radius);
      background: white;
      transition: var(--transition);
    }

    .faq-section details[open] {
      border-color: var(--accent-color);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .faq-section summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--primary-color);
      padding: 0.5rem;
      outline: none;
    }

    .faq-section summary:hover {
      color: var(--accent-color);
    }

    .faq-section p {
      margin-top: 1rem;
      padding-left: 1rem;
    }

    /* Breadcrumb Navigation */
    .breadcrumb {
      padding: 0.8rem 1rem;
      background: linear-gradient(to right, #f5f5f5, white);
      border-radius: var(--border-radius);
      margin-bottom: 2rem;
      font-size: 0.9rem;
    }

    .breadcrumb a {
      color: var(--secondary-color);
    }

    .breadcrumb a:hover {
      text-decoration: underline;
    }

    /* Problem Metadata */
    .problem-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin: 1.5rem 0;
      padding: 1rem;
      background: #f8f9fa;
      border-radius: var(--border-radius);
    }

    .meta-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9rem;
    }

    .meta-item .label {
      font-weight: 600;
      color: var(--meta-color);
    }

    /* Callout Boxes */
    .callout {
      padding: 1rem 1.5rem;
      margin: 1.5rem 0;
      border-radius: var(--border-radius);
      border-left: 4px solid;
    }

    .callout.tip {
      background-color: #e8f8f5;
      border-color: #1abc9c;
    }

    .callout.note {
      background-color: #eaf2f8;
      border-color: #3498db;
    }

    .callout.warning {
      background-color: #fef5e7;
      border-color: #f39c12;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      main {
        margin: 1rem;
        padding: 1.5rem;
      }

      h1 {
        font-size: 1.8rem;
      }

      h2 {
        font-size: 1.5rem;
      }

      .problem-meta {
        flex-direction: column;
      }

      table {
        display: block;
        overflow-x: auto;
      }
    }

    @media (max-width: 480px) {
      main {
        padding: 1rem;
      }

      h1 {
        font-size: 1.6rem;
      }

      h2 {
        font-size: 1.3rem;
      }

      pre {
        padding: 0.8rem;
        font-size: 0.85rem;
      }

      .tab-buttons {
        flex-wrap: wrap;
      }

      .tab-button {
        flex: 1 0 auto;
        padding: 0.6rem;
        font-size: 0.9rem;
      }
    }
  </style>
</head>

<body>
  <!-- Header will be inserted by JavaScript -->
  <div id="header"></div>

  <!-- Main Content -->
  <main>
    <!-- Breadcrumb Navigation -->
    <div class="breadcrumb">
      <a href="https://algopush.com">Home</a> &gt;
      <a href="https://algopush.com/Leetcode/leetcode.html">LeetCode</a> &gt;
      <span>Problem 2799</span>
    </div>

    <!-- Problem Visualization Image -->
    <div class="problem-visual">
      <img src="https://algopush.com/Leetcode/Images/2799.png" alt="Count Complete Subarrays in an Array"
        loading="lazy">
    </div>

    <h1>2799: Count Complete Subarrays in an Array</h1>

    <!-- Problem Metadata -->
    <div class="problem-meta">
      <div class="meta-item">
        <span class="label">Difficulty:</span>
        <span class="value">Easy</span>
      </div>
      <div class="meta-item">
        <span class="label">Topics:</span>
        <span class="value">Arrays, Sliding Window, Hash Map</span>
      </div>
      <div class="meta-item">
        <span class="label">Companies:</span>
        <span class="value">Google, Amazon, Microsoft</span>
      </div>
    </div>

    <div class="callout tip">
      <strong>Pro Tip:</strong> This problem is an excellent example of how to optimize from a brute force solution to
      an efficient sliding window approach. The optimal solution runs in O(n) time with O(n) space.
    </div>

    <p>
      The problem "Count Complete Subarrays in an Array" (LeetCode 2799) requires us to count how many subarrays contain
      all distinct elements present in the original array. A subarray is a contiguous part of the array.
    </p>

    <h2>Problem Statement</h2>
    <p>
      Given an array of positive integers <code>nums</code>, return the number of complete subarrays. A subarray is
      complete if it contains all the distinct elements present in the entire array.
    </p>

    <h3>Constraints</h3>
    <ul>
      <li><code>1 ≤ nums.length ≤ 100</code></li>
      <li><code>1 ≤ nums[i] ≤ 2000</code></li>
    </ul>

    <h2>Problem Link</h2>
    <p>
      <a href="https://leetcode.com/problems/count-complete-subarrays-in-an-array/" target="_blank"
        rel="noopener noreferrer">View on LeetCode ↗</a>
    </p>

    <h3>Example 1</h3>
    <pre><code><b>Input:</b> nums = [1, 3, 1, 2, 2]
<b>Output:</b> 4
<b>Explanation:</b> 
The distinct elements in the whole array are {1, 2, 3}.
The complete subarrays are:
[1, 3, 1, 2]
[1, 3, 1, 2, 2]
[3, 1, 2]
[3, 1, 2, 2]</code></pre>

    <div class="callout note">
      <strong>Note:</strong> The key insight is recognizing that we need to find all contiguous subarrays that contain
      all distinct elements from the original array.
    </div>

    <hr />

    <h2>Approach 1: Brute Force (Check All Subarrays)</h2>
    <p>
      The brute force approach checks every possible subarray to see if it contains all distinct elements from the
      original array.
    </p>

    <h3>Algorithm Steps</h3>
    <ol>
      <li><strong>Count</strong> the distinct elements in the entire array</li>
      <li><strong>Initialize</strong> a counter for complete subarrays</li>
      <li><strong>Iterate</strong> through all possible starting indices</li>
      <li><strong>For each starting index</strong>, iterate through all possible ending indices</li>
      <li><strong>For each subarray</strong>, count the distinct elements</li>
      <li><strong>If</strong> the count matches the total distinct elements, increment our counter</li>
      <li><strong>Return</strong> the total count</li>
    </ol>

    <h3>Complexity Analysis</h3>
    <table>
      <thead>
        <tr>
          <th>Time Complexity</th>
          <th>Space Complexity</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>O(n²)</td>
          <td>O(n)</td>
        </tr>
      </tbody>
    </table>

    <h3>Implementation</h3>

    <div class="code-tabs">
      <div class="tab-buttons">
        <button class="tab-button active" onclick="openTab(event, 'cpp-brute')">
          C++
        </button>
        <button class="tab-button" onclick="openTab(event, 'java-brute')">
          Java
        </button>
        <button class="tab-button" onclick="openTab(event, 'python-brute')">
          Python
        </button>
      </div>

      <div id="cpp-brute" class="tab-content active">
        <pre><code>
class Solution {
public:
    int countCompleteSubarrays(vector&lt;int&gt;& nums) {
        int count = 0;
        unordered_map&lt;int, int&gt; mp;
        for (int num : nums) {
            mp[num]++;
        }
        int totalDistinct = mp.size();

        for (int i = 0; i < nums.size(); i++) {
            unordered_map&lt;int, int&gt; temp;
            for (int j = i; j < nums.size(); j++) {
                temp[nums[j]]++;
                if (temp.size() == totalDistinct)
                    count++;
            }
        }
        return count;
    }
};
                </code></pre>
      </div>

      <div id="java-brute" class="tab-content">
        <pre><code>
class Solution {
    public int countCompleteSubarrays(int[] nums) {
        int count = 0;
        Set&lt;Integer&gt; distinct = new HashSet&lt;&gt;();
        for (int num : nums) {
            distinct.add(num);
        }
        int totalDistinct = distinct.size();

        for (int i = 0; i < nums.length; i++) {
            Set&lt;Integer&gt; current = new HashSet&lt;&gt;();
            for (int j = i; j < nums.length; j++) {
                current.add(nums[j]);
                if (current.size() == totalDistinct) {
                    count++;
                }
            }
        }
        return count;
    }
}
                </code></pre>
      </div>

      <div id="python-brute" class="tab-content">
        <pre><code>
class Solution:
    def countCompleteSubarrays(self, nums: List[int]) -> int:
        count = 0
        total_distinct = len(set(nums))
        
        for i in range(len(nums)):
            current = set()
            for j in range(i, len(nums)):
                current.add(nums[j])
                if len(current) == total_distinct:
                    count += 1
                    
        return count
                </code></pre>
      </div>
    </div>

    <div class="callout warning">
      <strong>Note:</strong> While this solution works, it's inefficient for larger arrays due to its O(n²) time
      complexity.
    </div>

    <hr />

    <h2>Approach 2: Sliding Window (Optimized)</h2>
    <p>
      The sliding window approach efficiently counts complete subarrays by maintaining a window that contains all
      distinct elements and calculating valid subarrays from that window.
    </p>

    <h3>Algorithm Steps</h3>
    <ol>
      <li><strong>Count</strong> the distinct elements in the entire array</li>
      <li><strong>Initialize</strong> two pointers (left and right) to represent the window</li>
      <li><strong>Use</strong> a hash map to track elements in the current window</li>
      <li><strong>Expand</strong> the window by moving the right pointer</li>
      <li><strong>When</strong> the window contains all distinct elements:
        <ul>
          <li>All subarrays ending at right pointer from current left are valid</li>
          <li>Add these to the count</li>
          <li>Move left pointer to try smaller windows</li>
        </ul>
      </li>
      <li><strong>Continue</strong> until all elements are processed</li>
    </ol>

    <h3>Complexity Analysis</h3>
    <table>
      <thead>
        <tr>
          <th>Time Complexity</th>
          <th>Space Complexity</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>O(n)</td>
          <td>O(n)</td>
        </tr>
      </tbody>
    </table>

    <h3>Implementation</h3>

    <div class="code-tabs">
      <div class="tab-buttons">
        <button class="tab-button active" onclick="openTab(event, 'cpp-sliding')">
          C++
        </button>
        <button class="tab-button" onclick="openTab(event, 'java-sliding')">
          Java
        </button>
        <button class="tab-button" onclick="openTab(event, 'python-sliding')">
          Python
        </button>
      </div>

      <div id="cpp-sliding" class="tab-content active">
        <pre><code>
class Solution {
public:
    int countCompleteSubarrays(vector&lt;int&gt;& nums) {
        int n = nums.size();
        unordered_set&lt;int&gt; distinct(nums.begin(), nums.end());
        int totalDistinct = distinct.size();

        unordered_map&lt;int, int&gt; window;
        int left = 0, count = 0;

        for (int right = 0; right < n; right++) {
            window[nums[right]]++;

            while (window.size() == totalDistinct) {
                count += n - right;
                window[nums[left]]--;
                if (window[nums[left]] == 0) {
                    window.erase(nums[left]);
                }
                left++;
            }
        }

        return count;
    }
};
                </code></pre>
      </div>

      <div id="java-sliding" class="tab-content">
        <pre><code>
class Solution {
    public int countCompleteSubarrays(int[] nums) {
        int n = nums.length;
        Set&lt;Integer&gt; distinct = new HashSet&lt;&gt;();
        for (int num : nums) distinct.add(num);
        int totalDistinct = distinct.size();

        Map&lt;Integer, Integer&gt; window = new HashMap&lt;&gt;();
        int left = 0, count = 0;

        for (int right = 0; right < n; right++) {
            window.put(nums[right], window.getOrDefault(nums[right], 0) + 1);

            while (window.size() == totalDistinct) {
                count += n - right;
                window.put(nums[left], window.get(nums[left]) - 1);
                if (window.get(nums[left]) == 0) {
                    window.remove(nums[left]);
                }
                left++;
            }
        }

        return count;
    }
}
                </code></pre>
      </div>

      <div id="python-sliding" class="tab-content">
        <pre><code>
class Solution:
    def countCompleteSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        total_distinct = len(set(nums))
        window = {}
        left = count = 0

        for right in range(n):
            window[nums[right]] = window.get(nums[right], 0) + 1

            while len(window) == total_distinct:
                count += n - right
                window[nums[left]] -= 1
                if window[nums[left]] == 0:
                    del window[nums[left]]
                left += 1

        return count
                </code></pre>
      </div>
    </div>

    <div class="callout tip">
      <strong>Why This Works:</strong> The sliding window approach efficiently tracks when we have all distinct elements
      in the current window and counts all valid subarrays from that point, avoiding the need to check every possible
      subarray.
    </div>

    <hr />

    <h2>Real-Life Analogy</h2>
    <p>
      Imagine you're collecting Pokémon cards. Your goal is to find all sets of continuous cards (subarrays) that
      include all types of Pokémon you have.
    </p>
    <ul>
      <li><strong>Brute Force:</strong> You check every possible pack manually to see if it has all Pokémon types.</li>
      <li><strong>Sliding Window:</strong> You keep adding cards to your hand until you have all Pokémon, then slide
        your hand forward to explore smaller possible complete sets.</li>
    </ul>

    <hr />

    <h2>Comparison of Approaches</h2>
    <table>
      <thead>
        <tr>
          <th>Approach</th>
          <th>Time Complexity</th>
          <th>Space Complexity</th>
          <th>When to Use</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Brute Force</td>
          <td>O(n²)</td>
          <td>O(n)</td>
          <td>Small inputs or when simplicity is preferred</td>
        </tr>
        <tr>
          <td>Sliding Window</td>
          <td>O(n)</td>
          <td>O(n)</td>
          <td>Larger inputs or when efficiency is critical</td>
        </tr>
      </tbody>
    </table>

    <div class="callout note">
      <strong>Interview Tip:</strong> Always mention the brute force solution first, then optimize it. The sliding
      window technique is a powerful pattern for subarray problems involving distinct elements.
    </div>

    <hr />

    <h2>Frequently Asked Questions</h2>

    <div class="faq-section">
      <details>
        <summary>
          1. What exactly is a "complete" subarray?
        </summary>
        <p>
          A complete subarray is a contiguous sequence of elements that contains all distinct elements present in the
          original array. For example, if the array has elements {1, 2, 3}, then any subarray containing at least one of
          each is complete.
        </p>
      </details>

      <details>
        <summary>
          2. Why does the sliding window approach work better?
        </summary>
        <p>
          The sliding window approach is more efficient because it processes each element at most twice (once when
          expanding the window, once when contracting it), resulting in O(n) time complexity compared to the brute force
          O(n²) approach.
        </p>
      </details>

      <details>
        <summary>
          3. How does the sliding window count all valid subarrays?
        </summary>
        <p>
          When the window contains all distinct elements, every subarray starting from the current left pointer to the
          end of the array (from the right pointer) is valid. That's why we add (n - right) to our count when the window
          contains all distinct elements.
        </p>
      </details>

      <details>
        <summary>
          4. What's the space complexity of these solutions?
        </summary>
        <p>
          Both solutions have O(n) space complexity because they need to store the distinct elements. The sliding window
          approach additionally needs space for the current window's elements.
        </p>
      </details>

      <details>
        <summary>
          5. Can this problem be solved with a fixed window size?
        </summary>
        <p>
          No, because complete subarrays can be of varying lengths. A fixed window approach wouldn't work since we need
          to find all subarrays that happen to contain all distinct elements, regardless of their size.
        </p>
      </details>

      <details>
        <summary>
          6. How would you handle negative numbers in the array?
        </summary>
        <p>
          The solutions would work the same way with negative numbers since we're only concerned with distinct values,
          not their sign. The hash map/set would store negative numbers without issues.
        </p>
      </details>

      <details>
        <summary>
          7. What if the array contains duplicate distinct elements?
        </summary>
        <p>
          The solutions still work because we first count the total distinct elements in the entire array, then look for
          subarrays that contain all of them, regardless of how many times each appears in the subarray.
        </p>
      </details>

      <details>
        <summary>
          8. Is there a way to solve this with O(1) space?
        </summary>
        <p>
          No, because we need to store information about the distinct elements, which requires O(n) space in the worst
          case where all elements are distinct.
        </p>
      </details>

      <details>
        <summary>
          9. How does the time complexity change if the array has all unique elements?
        </summary>
        <p>
          In the worst case where all elements are unique, both approaches still maintain their time complexities (O(n²)
          for brute force, O(n) for sliding window), though the sliding window would effectively check every
          single-element subarray.
        </p>
      </details>

      <details>
        <summary>
          10. What similar problems should I practice?
        </summary>
        <p>
          Recommended problems: 3 (Longest Substring Without Repeating Characters), 76 (Minimum Window Substring), 209
          (Minimum Size Subarray Sum), 904 (Fruit Into Baskets), and 930 (Binary Subarrays With Sum).
        </p>
      </details>
    </div>

    <div class="callout">
      <strong>Final Thoughts:</strong> This problem demonstrates the power of the sliding window technique for subarray
      problems. While the brute force solution is straightforward, the sliding window approach provides significant
      efficiency gains. Understanding both approaches will strengthen your problem-solving skills for coding interviews.
    </div>
  </main>

  <!-- Footer will be inserted by JavaScript -->
  <div id="footer"></div>

</body>

</html>