<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1. Two Sum | LeetCode Solution</title>
    <meta name="description" 
        content="Complete solution for LeetCode Two Sum problem with efficient algorithms, multiple approaches, and code implementations in C++, Java, and Python.">
    <meta name="keywords"
        content="LeetCode, Two Sum, Hash Table, Array, Algorithm, Solution, Coding Interview, LeetCode Medium Problem, Competitive Programming, leetcode, leetcode problem of the day, leetcode contest question, leetcode easy question, leetcode medium question, leetcode daily question, Leetcode dsa interview question, sde interview question">
    <meta name="author" content="Algopush">
    <link rel="canonical" href="https://algopush.com/Leetcode/1-two-sum.html">
    
    <!-- Favicon -->
    <link rel="icon" href="../components/favicon.png" type="image/x-icon">
    <link rel="apple-touch-icon" href="../components/favicon.png">

    <!-- Open Graph / Social Media Meta Tags -->
    <meta property="og:title" content="1. Two Sum | LeetCode Solution">
    <meta property="og:description"
        content="Efficient solutions for LeetCode Two Sum problem with multiple approaches and code implementations.">
    <meta property="og:image" content="https://algopush.com/Leetcode/Images/1.png">
    <meta property="og:url" content="https://algopush.com/Leetcode/1-two-sum.html">

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="LeetCode 1: Two Sum Solution">
    <meta name="twitter:description"
        content="Complete solution for LeetCode Two Sum problem with efficient algorithms and code implementations.">
    <meta name="twitter:image" content="https://algopush.com/Leetcode/Images/1.png">

    <!-- Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "TechArticle",
        "headline": "Two Sum Solution Guide",
        "url": "https://algopush.com/Leetcode/1-two-sum.html",
        "image": "https://algopush.com/Leetcode/Images/1.png",
        "author": {
            "@type": "Organization",
            "name": "Algopush",
            "url": "https://algopush.com"
        },
        "datePublished": "2025-06-21",
        "publisher": {
            "@type": "Organization",
            "name": "Algopush",
            "logo": {
                "@type": "ImageObject",
                "url": "https://algopush.com/components/logo.png"
            }
        }
    }
    </script>
    <style>
        :root {
            --primary-color: #102c41;
            --secondary-color: #196391;
            --accent-color: #102c41;
            --meta-color: #db5305;
            --light-bg: #f5f9fc;
            --highlight-color: #f5f9fc;
            --text-color: black;
            --light-text: #7f8c8d;
            --border-radius: 6px;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
            --callout-tip: #e8f8f5;
            --callout-note: #eaf2f8;
            --callout-warning: #fef5e7;
            --callout-danger: #ffebee;
            --callout-tip-border: #1abc9c;
            --callout-note-border: #3498db;
            --callout-warning-border: #f39c12;
            --callout-danger-border: #f44336;
        }

        /* Base Styles */
        body {
            margin: 0;
            padding: 0;
            font-family: "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            background-color: var(--light-bg);
            color: var(--text-color);
            line-height: 1.7;
            font-size: 1.05rem;
        }

        /* Main Content Container */
        main {
            max-width: 920px;
            margin: 2rem auto;
            padding: 2rem;
            background: #fff;
            box-shadow: var(--box-shadow);
            border-radius: var(--border-radius);
        }

        /* Problem Visualization Image */
        .problem-visual {
            max-width: 100%;
            margin: 1.5rem 0;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--box-shadow);
            text-align: center;
            }

            .problem-visual img {
            max-width: 100%;
            height: auto;
            max-height: 400px;
            display: inline-block;
        }

        /* Typography */
        h1,
        h2,
        h3,
        h4 {
            color: var(--primary-color);
            font-weight: 600;
            margin-top: 1.8rem;
            margin-bottom: 1rem;
            line-height: 1.3;
        }

        h1 {
            font-size: 2rem;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.5rem;
        }

        h2 {
            font-size: 1.6rem;
            border-left: 4px solid var(--accent-color);
            padding-left: 0.8rem;
        }

        h3 {
            font-size: 1.3rem;
            color: var(--secondary-color);
        }

        a {
            color: var(--accent-color);
            text-decoration: none;
            transition: var(--transition);
        }

        a:hover {
            color: var(--primary-color);
            text-decoration: underline;
        }

        hr {
            border: 0;
            height: 1px;
            background: #ddd;
        }

        /* Code Blocks */
        pre {
            background: #f8f9fa;
            margin-top: 0.5rem;
            padding: 1.2rem;
            border-radius: var(--border-radius);
            overflow-x: auto;
            border-left: 4px solid var(--accent-color);
            font-size: 0.95rem;
            line-height: 1.5;
        }

        code {
            font-family: monospace;
            color: #2c3e50;
        }

        /* LeetCode-like Syntax Highlighting with Light Theme */
        .code-token-keyword {
            color: #007acc;
        }

        .code-token-function {
            color: #795e26;
        }

        .code-token-number {
            color: #098658;
        }

        .code-token-string {
            color: #a31515;
        }

        .code-token-comment {
            color: #6a737d;
            font-style: italic;
        }

        /* Highlight Callouts */
        .highlight {
            background: var(--highlight-color);
            padding: 1rem;
            border-radius: var(--border-radius);
            margin: 1.5rem 0;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        th,
        td {
            padding: 0.8rem;
            text-align: center;
            border: 1px solid #ddd;
        }

        th {
            background-color: var(--primary-color);
            color: white;
            font-weight: 500;
        }

        tr:nth-child(even) {
            background-color: #f2f2f2;
        }

        /* Code Container */
        .code-container {
            position: relative;
            margin: 1.5rem 0;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--box-shadow);
        }

        .code-header {
            background: var(--primary-color);
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
        }

        .code-filename {
            font-weight: 600;
        }

        .code-copy {
            background: white;
            color: var(--primary-color);
            border: none;
            padding: 0.25rem 0.75rem;
            border-radius: 3px;
            cursor: pointer;
            transition: var(--transition);
            font-weight: 500;
        }

        .code-copy:hover {
            background: var(--highlight-color);
        }

        /* Tabs */
        .code-tabs {
            margin: 0.5rem 0;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--box-shadow);
        }

        .tab-buttons {
            display: flex;
            background: #eaecee;
            border-bottom: 1px solid #ddd;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .tab-button {
            padding: 0.7rem 1.2rem;
            background: transparent;
            border: none;
            cursor: pointer;
            font-weight: 500;
            color: var(--text-color);
            transition: var(--transition);
            white-space: nowrap;
            flex-shrink: 0;
        }

        .tab-button.active {
            background: var(--primary-color);
            color: white;
        }

        .tab-button:hover:not(.active) {
            background: #d5dbdb;
        }

        .tab-content {
            display: none;
            background: white;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }


        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        /* FAQ Section */
        .faq-section {
            margin: 2rem 0;
        }

        .faq-section details {
            margin: 0.8rem 0;
            padding: 0.1rem;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            background: white;
            transition: var(--transition);
        }

        .faq-section details[open] {
            border-color: var(--accent-color);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            background: #f9f9f9;
        }

        .faq-section summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--primary-color);
            padding: 0.8rem;
            outline: none;
            transition: var(--transition);
        }

        .faq-section summary:hover {
            color: var(--accent-color);
            background: #f5f5f5;
        }

        .faq-section p {
            margin-top: 1rem;
            padding: 0 1rem 1rem;
        }

        /* Breadcrumb Navigation */
        .breadcrumb {
            padding: 0.8rem 1rem;
            background: linear-gradient(to right, #f5f5f5, white);
            border-radius: var(--border-radius);
            margin-bottom: 2rem;
            font-size: 0.9rem;
        }

        .breadcrumb a {
            color: var(--secondary-color);
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        /* Problem Metadata */
        .problem-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin: 1.5rem 0;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: var(--border-radius);
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .meta-item .label {
            font-weight: 600;
            color: var(--meta-color);
        }

        /* Callout Boxes */
        .callout {
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            border-radius: var(--border-radius);
            border-left: 4px solid;
        }

        .callout.tip {
            background-color: var(--callout-tip);
            border-color: var(--callout-tip-border);
        }

        .callout.note {
            background-color: var(--callout-note);
            border-color: var(--callout-note-border);
        }

        .callout.warning {
            background-color: var(--callout-warning);
            border-color: var(--callout-warning-border);
        }

        .callout.danger {
            background-color: var(--callout-danger);
            border-color: var(--callout-danger-border);
        }

        .callout strong {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--primary-color);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            main {
                margin: 1rem;
                padding: 1.5rem;
            }

            h1 {
                font-size: 1.7rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            .problem-meta {
                flex-direction: column;
            }

            table {
                display: block;
                overflow-x: auto;
            }
        }

        @media (max-width: 480px) {
            main {
                padding: 1rem;
            }

            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.2rem;
            }

            pre {
                padding: 0.8rem;
                font-size: 0.85rem;
            }

            .tab-button {
                padding: 0.6rem;
                font-size: 0.9rem;
            }

            .code-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .code-copy {
                margin-top: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div id="header"></div>

    <main>
        <div class="breadcrumb">
            <a href="https://algopush.com">Home</a> &gt;
            <a href="https://algopush.com/Leetcode/leetcode.html">LeetCode</a> &gt;
            <span>1. Two Sum</span>
        </div>

        <div class="problem-visual">
            <img src="https://algopush.com/Leetcode/Images/1.png" alt="Two Sum Visualization">
        </div>

        <h1>1. Two Sum</h1>

        <div class="problem-meta">
            <div class="meta-item">
                <span class="label">Difficulty:</span>
                <span class="value">Easy</span>
            </div>
            <div class="meta-item">
                <span class="label">Topics:</span>
                <span class="value">Array, Hash Table</span>
            </div>
            <div class="meta-item">
                <span class="label">Companies:</span>
                <span class="value">Google, Amazon, Microsoft, Apple, Meta</span>
            </div>
        </div>

        <h2>Problem Statement</h2>
        <p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return indices of the two numbers such that they add up to <code>target</code>.</p>
        <p>You may assume that each input would have <strong>exactly one solution</strong>, and you may not use the same element twice.</p>
        <p>You can return the answer in any order.</p>

        <h3>Example 1</h3>
        <pre><code>Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].</code></pre>

        <h3>Example 2</h3>
        <pre><code>Input: nums = [3,2,4], target = 6
Output: [1,2]</code></pre>

        <h3>Example 3</h3>
        <pre><code>Input: nums = [3,3], target = 6
Output: [0,1]</code></pre>

        <div class="callout note">
            <strong>Problem Link:</strong>
            <a href="https://leetcode.com/problems/two-sum/" target="_blank">
                View on LeetCode ↗
            </a>
        </div>

        <hr>

        <h2>Approach 1: Brute Force</h2>
        <p>The simplest approach involves checking every possible pair in the array to see if their sum equals the target.</p>

        <h3>Algorithm Steps</h3>
        <ol>
            <li>Iterate through each element in the array</li>
            <li>For each element, iterate through the rest of the array</li>
            <li>Check if the current element and any subsequent element sum to the target</li>
            <li>Return the indices when a valid pair is found</li>
        </ol>

        <div class="code-container">
            <div class="code-header">
                <span class="code-filename">Brute Force Solution</span>
                <button class="code-copy">Copy Code</button>
            </div>

            <div class="code-tabs">
                <div class="tab-buttons">
                    <button class="tab-button active" data-tab="cpp-brute">C++</button>
                    <button class="tab-button" data-tab="java-brute">Java</button>
                    <button class="tab-button" data-tab="python-brute">Python</button>
                </div>

                <!-- C++ Code -->
                <div class="tab-content active" id="cpp-brute-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
<span class="code-token-keyword">public</span>:
    vector&lt;<span class="code-token-keyword">int</span>&gt; <span class="code-token-function">twoSum</span>(vector&lt;<span class="code-token-keyword">int</span>&gt;& nums, <span class="code-token-keyword">int</span> target) {
        <span class="code-token-keyword">int</span> n = nums.size();
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i < n; i++) {
            <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> j = i + 1; j < n; j++) {
                <span class="code-token-keyword">if</span> (nums[i] + nums[j] == target) {
                    <span class="code-token-keyword">return</span> {i, j};
                }
            }
        }
        <span class="code-token-keyword">return</span> {};
    }
};</code></pre>
                </div>

                <!-- Java Code -->
                <div class="tab-content" id="java-brute-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
    <span class="code-token-keyword">public</span> <span class="code-token-keyword">int</span>[] twoSum(<span class="code-token-keyword">int</span>[] nums, <span class="code-token-keyword">int</span> target) {
        <span class="code-token-keyword">int</span> n = nums.length;
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i < n; i++) {
            <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> j = i + 1; j < n; j++) {
                <span class="code-token-keyword">if</span> (nums[i] + nums[j] == target) {
                    <span class="code-token-keyword">return</span> <span class="code-token-keyword">new</span> <span class="code-token-keyword">int</span>[] {i, j};
                }
            }
        }
        <span class="code-token-keyword">return</span> <span class="code-token-keyword">new</span> <span class="code-token-keyword">int</span>[0];
    }
}</code></pre>
                </div>

                <!-- Python Code -->
                <div class="tab-content" id="python-brute-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span>:
    <span class="code-token-keyword">def</span> <span class="code-token-function">twoSum</span>(self, nums: List[<span class="code-token-keyword">int</span>], target: <span class="code-token-keyword">int</span>) -> List[<span class="code-token-keyword">int</span>]:
        n = len(nums)
        <span class="code-token-keyword">for</span> i <span class="code-token-keyword">in</span> range(n):
            <span class="code-token-keyword">for</span> j <span class="code-token-keyword">in</span> range(i + 1, n):
                <span class="code-token-keyword">if</span> nums[i] + nums[j] == target:
                    <span class="code-token-keyword">return</span> [i, j]
        <span class="code-token-keyword">return</span> []</code></pre>
                </div>
            </div>

            <div class="callout note">
                <strong>Complexity:</strong> O(n²) time, O(1) space
            </div>
        </div>

        <hr>

        <h2>Approach 2: Two-pass Hash Table</h2>
        <p>This approach reduces the time complexity by using a hash table to store element indices for quick lookups.</p>

        <h3>Algorithm Steps</h3>
        <ol>
            <li>Create a hash map to store element-value to index mappings</li>
            <li>In the first pass, populate the hash map with all elements</li>
            <li>In the second pass, for each element, calculate the complement (target - current element)</li>
            <li>Check if the complement exists in the hash map and is not the same element</li>
            <li>Return the indices when a valid pair is found</li>
        </ol>

        <div class="code-container">
            <div class="code-header">
                <span class="code-filename">Two-pass Hash Table Solution</span>
                <button class="code-copy">Copy Code</button>
            </div>

            <div class="code-tabs">
                <div class="tab-buttons">
                    <button class="tab-button active" data-tab="cpp-two-pass">C++</button>
                    <button class="tab-button" data-tab="java-two-pass">Java</button>
                    <button class="tab-button" data-tab="python-two-pass">Python</button>
                </div>

                <!-- C++ Code -->
                <div class="tab-content active" id="cpp-two-pass-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
<span class="code-token-keyword">public</span>:
    vector&lt;<span class="code-token-keyword">int</span>&gt; <span class="code-token-function">twoSum</span>(vector&lt;<span class="code-token-keyword">int</span>&gt;& nums, <span class="code-token-keyword">int</span> target) {
        unordered_map&lt;<span class="code-token-keyword">int</span>, <span class="code-token-keyword">int</span>&gt; numMap;
        <span class="code-token-keyword">int</span> n = nums.size();
        
        <span class="code-token-comment">// Build the hash table</span>
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i < n; i++) {
            numMap[nums[i]] = i;
        }
        
        <span class="code-token-comment">// Find the complement</span>
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i < n; i++) {
            <span class="code-token-keyword">int</span> complement = target - nums[i];
            <span class="code-token-keyword">if</span> (numMap.find(complement) != numMap.end() && numMap[complement] != i) {
                <span class="code-token-keyword">return</span> {i, numMap[complement]};
            }
        }
        <span class="code-token-keyword">return</span> {};
    }
};</code></pre>
                </div>

                <!-- Java Code -->
                <div class="tab-content" id="java-two-pass-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
    <span class="code-token-keyword">public</span> <span class="code-token-keyword">int</span>[] twoSum(<span class="code-token-keyword">int</span>[] nums, <span class="code-token-keyword">int</span> target) {
        Map&lt;Integer, Integer&gt; numMap = <span class="code-token-keyword">new</span> HashMap&lt;&gt;();
        <span class="code-token-keyword">int</span> n = nums.length;
        
        <span class="code-token-comment">// Build the hash table</span>
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i < n; i++) {
            numMap.put(nums[i], i);
        }
        
        <span class="code-token-comment">// Find the complement</span>
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i < n; i++) {
            <span class="code-token-keyword">int</span> complement = target - nums[i];
            <span class="code-token-keyword">if</span> (numMap.containsKey(complement) && numMap.get(complement) != i) {
                <span class="code-token-keyword">return</span> <span class="code-token-keyword">new</span> <span class="code-token-keyword">int</span>[] {i, numMap.get(complement)};
            }
        }
        <span class="code-token-keyword">return</span> <span class="code-token-keyword">new</span> <span class="code-token-keyword">int</span>[0];
    }
}</code></pre>
                </div>

                <!-- Python Code -->
                <div class="tab-content" id="python-two-pass-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span>:
    <span class="code-token-keyword">def</span> <span class="code-token-function">twoSum</span>(self, nums: List[<span class="code-token-keyword">int</span>], target: <span class="code-token-keyword">int</span>) -> List[<span class="code-token-keyword">int</span>]:
        num_map = {}
        n = len(nums)
        
        <span class="code-token-comment"># Build the hash table</span>
        <span class="code-token-keyword">for</span> i <span class="code-token-keyword">in</span> range(n):
            num_map[nums[i]] = i
            
        <span class="code-token-comment"># Find the complement</span>
        <span class="code-token-keyword">for</span> i <span class="code-token-keyword">in</span> range(n):
            complement = target - nums[i]
            <span class="code-token-keyword">if</span> complement <span class="code-token-keyword">in</span> num_map <span class="code-token-keyword">and</span> num_map[complement] != i:
                <span class="code-token-keyword">return</span> [i, num_map[complement]]
        <span class="code-token-keyword">return</span> []</code></pre>
                </div>
            </div>

            <div class="callout note">
                <strong>Complexity:</strong> O(n) time, O(n) space
            </div>
        </div>

        <hr>

        <h2>Approach 3: One-pass Hash Table (Optimal)</h2>
        <p>The most efficient solution that completes the task in a single pass through the array.</p>

        <h3>Algorithm Steps</h3>
        <ol>
            <li>Create a hash map to store element indices</li>
            <li>Iterate through the array</li>
            <li>For each element, calculate the complement (target - current element)</li>
            <li>Check if the complement exists in the hash map</li>
            <li>If found, return the indices immediately</li>
            <li>Otherwise, add the current element and its index to the map</li>
        </ol>

        <div class="code-container">
            <div class="code-header">
                <span class="code-filename">One-pass Hash Table Solution</span>
                <button class="code-copy">Copy Code</button>
            </div>

            <div class="code-tabs">
                <div class="tab-buttons">
                    <button class="tab-button active" data-tab="cpp-one-pass">C++</button>
                    <button class="tab-button" data-tab="java-one-pass">Java</button>
                    <button class="tab-button" data-tab="python-one-pass">Python</button>
                </div>

                <!-- C++ Code -->
                <div class="tab-content active" id="cpp-one-pass-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
<span class="code-token-keyword">public</span>:
    vector&lt;<span class="code-token-keyword">int</span>&gt; <span class="code-token-function">twoSum</span>(vector&lt;<span class="code-token-keyword">int</span>&gt;& nums, <span class="code-token-keyword">int</span> target) {
        unordered_map&lt;<span class="code-token-keyword">int</span>, <span class="code-token-keyword">int</span>&gt; numMap;
        <span class="code-token-keyword">int</span> n = nums.size();
        
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i < n; i++) {
            <span class="code-token-keyword">int</span> complement = target - nums[i];
            <span class="code-token-keyword">if</span> (numMap.find(complement) != numMap.end()) {
                <span class="code-token-keyword">return</span> {numMap[complement], i};
            }
            numMap[nums[i]] = i;
        }
        <span class="code-token-keyword">return</span> {};
    }
};</code></pre>
                </div>

                <!-- Java Code -->
                <div class="tab-content" id="java-one-pass-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
    <span class="code-token-keyword">public</span> <span class="code-token-keyword">int</span>[] twoSum(<span class="code-token-keyword">int</span>[] nums, <span class="code-token-keyword">int</span> target) {
        Map&lt;Integer, Integer&gt; numMap = <span class="code-token-keyword">new</span> HashMap&lt;&gt;();
        <span class="code-token-keyword">int</span> n = nums.length;
        
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i < n; i++) {
            <span class="code-token-keyword">int</span> complement = target - nums[i];
            <span class="code-token-keyword">if</span> (numMap.containsKey(complement)) {
                <span class="code-token-keyword">return</span> <span class="code-token-keyword">new</span> <span class="code-token-keyword">int</span>[] {numMap.get(complement), i};
            }
            numMap.put(nums[i], i);
        }
        <span class="code-token-keyword">return</span> <span class="code-token-keyword">new</span> <span class="code-token-keyword">int</span>[0];
    }
}</code></pre>
                </div>

                <!-- Python Code -->
                <div class="tab-content" id="python-one-pass-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span>:
    <span class="code-token-keyword">def</span> <span class="code-token-function">twoSum</span>(self, nums: List[<span class="code-token-keyword">int</span>], target: <span class="code-token-keyword">int</span>) -> List[<span class="code-token-keyword">int</span>]:
        num_map = {}
        <span class="code-token-keyword">for</span> i, num <span class="code-token-keyword">in</span> enumerate(nums):
            complement = target - num
            <span class="code-token-keyword">if</span> complement <span class="code-token-keyword">in</span> num_map:
                <span class="code-token-keyword">return</span> [num_map[complement], i]
            num_map[num] = i
        <span class="code-token-keyword">return</span> []</code></pre>
                </div>
            </div>

            <div class="callout tip">
                <strong>Optimal Solution:</strong> O(n) time, O(n) space - most efficient for large inputs
            </div>
        </div>

        <hr>

        <h2>Approach Comparison</h2>
        <table>
            <thead>
                <tr>
                    <th>Approach</th>
                    <th>Time</th>
                    <th>Space</th>
                    <th>Best For</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Brute Force</td>
                    <td>O(n²)</td>
                    <td>O(1)</td>
                    <td>Small arrays</td>
                </tr>
                <tr>
                    <td>Two-pass Hash Table</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                    <td>Medium arrays</td>
                </tr>
                <tr>
                    <td>One-pass Hash Table</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                    <td>All cases (optimal)</td>
                </tr>
            </tbody>
        </table>

        <div class="callout tip">
            <strong>Recommendation:</strong> One-pass Hash Table is the optimal solution for most cases
        </div>

        <hr>

        <h2>Edge Cases</h2>
        <h3>1. Duplicate elements</h3>
        <pre><code>Input: nums = [3,3], target = 6 → Output: [0,1]</code></pre>

        <h3>2. Negative numbers</h3>
        <pre><code>Input: nums = [-1,-2,-3,-4,-5], target = -8 → Output: [2,4]</code></pre>

        <h3>3. Zero as target</h3>
        <pre><code>Input: nums = [0,4,3,0], target = 0 → Output: [0,3]</code></pre>

        <h3>4. Large input size</h3>
        <pre><code>Input: nums = [1,2,...,10000], target = 19999 → Output: [9999,10000]</code></pre>

        <div class="callout warning">
            <strong>Important:</strong> Handle duplicate elements carefully to avoid using the same element twice
        </div>

        <hr>

        <script type="text/javascript"> var infolinks_pid = 3438220; var infolinks_wsid = 0; </script> <script type="text/javascript" src="//resources.infolinks.com/js/infolinks_main.js"></script>

        <h2>Frequently Asked Questions</h2>
        <div class="faq-section">
            <details>
                <summary>Why is the hash table approach more efficient?</summary>
                <p>The hash table reduces the time complexity from O(n²) to O(n) by allowing O(1) lookups for complements.</p>
            </details>

            <details>
                <summary>How does the one-pass approach handle duplicates?</summary>
                <p>Since we check for the complement before adding the current element to the map, we avoid using the same element twice.</p>
            </details>

            <details>
                <summary>What if there are multiple valid answers?</summary>
                <p>The problem states there's exactly one solution, so we don't need to handle multiple answers.</p>
            </details>

            <details>
                <summary>Can we use a different data structure?</summary>
                <p>A hash table provides the best average-case performance. Alternatives like balanced BSTs would have O(n log n) time.</p>
            </details>

            <details>
                <summary>How does the solution handle negative numbers?</summary>
                <p>The algorithm works with negative numbers since complement calculation and hash lookups function the same.</p>
            </details>

            <details>
                <summary>Is the solution order-sensitive?</summary>
                <p>The order of returned indices doesn't matter, as long as they point to elements that sum to the target.</p>
            </details>

            <details>
                <summary>What happens if no solution is found?</summary>
                <p>The problem guarantees one solution, but in practice, we return an empty list/array.</p>
            </details>

            <details>
                <summary>Can we solve with constant space?</summary>
                <p>For unsorted arrays, constant space solutions would require O(n²) time (brute force).</p>
            </details>

            <details>
                <summary>How would you handle sorted input?</summary>
                <p>For sorted arrays, we could use a two-pointer approach with O(n) time and O(1) space.</p>
            </details>

            <details>
                <summary>Why use unordered_map in C++?</summary>
                <p>unordered_map provides average O(1) time for operations, while map would be O(log n).</p>
            </details>

            <details>
                <summary>What's the worst-case for the hash table approach?</summary>
                <p>Worst-case is O(n) per operation (if many collisions), but average case is O(1).</p>
            </details>

            <details>
                <summary>How does Python's dictionary handle collisions?</summary>
                <p>Python uses open addressing with pseudo-random probing for collision resolution.</p>
            </details>

            <details>
                <summary>Can we optimize for memory?</summary>
                <p>If memory is critical, the brute force approach uses O(1) space but sacrifices time efficiency.</p>
            </details>
        </div>

        <div class="callout">
            <strong>Final Recommendation:</strong> The one-pass hash table solution is optimal for both time and space complexity in real-world scenarios.
        </div>
    </main>

    <div id="footer"></div>
    <script>
        // Same as previous solution
        document.addEventListener('DOMContentLoaded', function () {
            document.querySelectorAll('.code-tabs').forEach(container => {
                const tabButtons = container.querySelectorAll('.tab-button');
                const tabContents = container.querySelectorAll('.tab-content');

                if (!container.querySelector('.tab-button.active')) {
                    tabButtons[0]?.classList.add('active');
                    tabContents[0]?.classList.add('active');
                }

                tabButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const tabName = button.getAttribute('data-tab');

                        // Update active tab button
                        tabButtons.forEach(btn => btn.classList.remove('active'));
                        button.classList.add('active');

                        // Update active tab content
                        tabContents.forEach(content => content.classList.remove('active'));
                        container.querySelector(`#${tabName}-tab`).classList.add('active');
                    });
                });
            });

            document.querySelectorAll('.code-copy').forEach(button => {
                button.addEventListener('click', () => {
                    const activeTab = button.closest('.code-container').querySelector('.tab-content.active');
                    const code = activeTab.querySelector('code').innerText;
                    navigator.clipboard.writeText(code).then(() => {
                        const originalText = button.textContent;
                        button.textContent = 'Copied!';
                        setTimeout(() => button.textContent = originalText, 2000);
                    });
                });
            });

            document.querySelectorAll('.faq-section details').forEach(detail => {
                detail.addEventListener('toggle', () => {
                    if (detail.open) {
                        detail.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                });
            });

            // Load header and footer
            fetch("../components/header.html")
                .then((response) => response.text())
                .then((data) => {
                    document.getElementById("header").innerHTML = data;
                });

            fetch("../components/footer.html")
                .then((response) => response.text())
                .then((data) => {
                    document.getElementById("footer").innerHTML = data;
                });
        });
    </script>
</body>
</html>