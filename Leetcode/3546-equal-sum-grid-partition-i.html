<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LeetCode 3546 | Equal Sum Grid Partition I</title>
  <meta name="description"
    content="LeetCode 3546: Learn efficient methods to partition grids into equal sums. Detailed analysis with matrix traversal techniques and Python/Java/C++ code.">
  <meta name="keywords"
    content="LeetCode 3546, Grid Partition, Matrix Algorithms, Array Manipulation, Equal Sum Partition, Competitive Programming, leetcode, leetcode problem of the day, leetcode contest question, leetcode easy question, leetcode medium question,leetcode daily question, Leetcode company dsa problem">
  <meta name="author" content="Algopush" />
  <link rel="canonical" href="https://algopush.com/Leetcode/3546-equal-sum-grid-partition-i.html">

  <!-- Favicon -->
  <link rel="icon" href="../components/favicon.png" type="image/x-icon">
  <link rel="apple-touch-icon" href="../components/favicon.png">

  <!-- Open Graph / Social Media Meta Tags -->
  <meta property="og:title" content="LeetCode 3546: Equal Sum Grid Partition I">
  <meta property="og:description"
    content="Master grid partitioning techniques for equal sums with optimal time complexity. Complete guide with mathematical proofs and multi-language implementations.">
  <meta property="og:image" content="https://algopush.com/Leetcode/Images/3546.png">
  <meta property="og:url" content="https://algopush.com/Leetcode/3546-equal-sum-grid-partition-i.html">
  <meta property="og:type" content="article">

  <!-- Twitter Card Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="LeetCode 3546: Equal Sum Grid Partition I">
  <meta name="twitter:description"
    content="Optimal solution for grid partitioning with horizontal/vertical cuts. Code examples in Python, Java, and C++.">
  <meta name="twitter:image" content="https://algopush.com/Leetcode/Images/3546.png">

  <!-- Structured Data for SEO -->
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "TechArticle",
      "headline": "Equal Sum Grid Partition I",
      "url": "https://algopush.com/Leetcode/3546-equal-sum-grid-partition-i.html",
      "image": "https://algopush.com/Leetcode/Images/3546.png",
      "author": {
        "@type": "Organization",
        "name": "Algopush",
        "url": "https://algopush.com"
      },
      "datePublished": "2025-05-15",
      "dateModified": "2025-05-15",
      "publisher": {
        "@type": "Organization",
        "name": "Algopush",
        "logo": {
          "@type": "ImageObject",
          "url": "https://algopush.com/components/logo.png"
        }
      }
    }
  </script>

  <style>
    :root {
      --primary-color: #102c41;
      --secondary-color: #196391;
      --accent-color: #102c41;
      --meta-color: #db5305;
      --light-bg: #f5f9fc;
      --highlight-color: #f5f9fc;
      --text-color: black;
      --light-text: #7f8c8d;
      --border-radius: 6px;
      --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --transition: all 0.3s ease;
      --callout-tip: #e8f8f5;
      --callout-note: #eaf2f8;
      --callout-warning: #fef5e7;
      --callout-danger: #ffebee;
      --callout-tip-border: #1abc9c;
      --callout-note-border: #3498db;
      --callout-warning-border: #f39c12;
      --callout-danger-border: #f44336;
    }

    /* Base Styles */
    body {
      margin: 0;
      padding: 0;
      font-family: "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
      background-color: var(--light-bg);
      color: var(--text-color);
      line-height: 1.7;
      font-size: 1.05rem;
    }

    /* Main Content Container */
    main {
      max-width: 920px;
      margin: 2rem auto;
      padding: 2rem;
      background: #fff;
      box-shadow: var(--box-shadow);
      border-radius: var(--border-radius);
    }

    /* Problem Visualization Image */
    .problem-visual {
      max-width: 100%;
      margin: 1.5rem 0;
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: var(--box-shadow);
      text-align: center;
    }

    .problem-visual img {
      max-width: 100%;
      height: auto;
      max-height: 400px;
      display: inline-block;
    }

    /* Typography */
    h1,
    h2,
    h3,
    h4 {
      color: var(--primary-color);
      font-weight: 600;
      margin-top: 1.8rem;
      margin-bottom: 1rem;
      line-height: 1.3;
    }

    h1 {
      font-size: 2rem;
      border-bottom: 2px solid var(--primary-color);
      padding-bottom: 0.5rem;
    }

    h2 {
      font-size: 1.6rem;
      border-left: 4px solid var(--accent-color);
      padding-left: 0.8rem;
    }

    h3 {
      font-size: 1.3rem;
      color: var(--secondary-color);
    }

    a {
      color: var(--accent-color);
      text-decoration: none;
      transition: var(--transition);
    }

    a:hover {
      color: var(--primary-color);
      text-decoration: underline;
    }

    hr {
      border: 0;
      height: 1px;
      background: #ddd;
    }

    /* Code Blocks */
    pre {
      background: #f8f9fa;
      padding: 1.2rem;
      border-radius: var(--border-radius);
      overflow-x: auto;
      border-left: 4px solid var(--accent-color);
      font-size: 0.95rem;
      line-height: 1.5;
    }

    code {
      font-family: monospace;
      color: #2c3e50;
    }

    .highlight {
      background: var(--highlight-color);
      padding: 1rem;
      border-radius: var(--border-radius);
      margin: 1.5rem 0;
    }

    /* Tables */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1.5rem 0;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    th,
    td {
      padding: 0.8rem;
      text-align: center;
      border: 1px solid #ddd;
    }

    th {
      background-color: var(--primary-color);
      color: white;
      font-weight: 500;
    }

    tr:nth-child(even) {
      background-color: #f2f2f2;
    }

    /* Code Container */
    .code-container {
      position: relative;
      margin: 1.5rem 0;
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: var(--box-shadow);
    }

    .code-header {
      background: var(--primary-color);
      padding: 0.5rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: white;
    }

    .code-filename {
      font-weight: 600;
    }

    .code-copy {
      background: white;
      color: var(--primary-color);
      border: none;
      padding: 0.25rem 0.75rem;
      border-radius: 3px;
      cursor: pointer;
      transition: var(--transition);
      font-weight: 500;
    }

    .code-copy:hover {
      background: var(--highlight-color);
    }

    /* Code Syntax Highlighting */
    .code-token-keyword {
      color: #d73a49;
    }

    .code-token-function {
      color: #6f42c1;
    }

    .code-token-comment {
      color: #6a737d;
      font-style: italic;
    }

    .code-token-string {
      color: #032f62;
    }

    .code-token-number {
      color: #005cc5;
    }

    /* Tabs */
    .code-tabs {
      margin: 0.5rem 0;
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: var(--box-shadow);
    }

    .tab-buttons {
      display: flex;
      background: #eaecee;
      border-bottom: 1px solid #ddd;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    .tab-button {
      padding: 0.7rem 1.2rem;
      background: transparent;
      border: none;
      cursor: pointer;
      font-weight: 500;
      color: var(--text-color);
      transition: var(--transition);
      white-space: nowrap;
      flex-shrink: 0;
    }

    .tab-button.active {
      background: var(--primary-color);
      color: white;
    }

    .tab-button:hover:not(.active) {
      background: #d5dbdb;
    }

    .tab-content {
      display: none;
      background: white;
    }

    .tab-content.active {
      display: block;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    /* FAQ Section */
    .faq-section {
      margin: 2rem 0;
    }

    .faq-section details {
      margin: 0.8rem 0;
      padding: 0.1rem;
      border: 1px solid #ddd;
      border-radius: var(--border-radius);
      background: white;
      transition: var(--transition);
    }

    .faq-section details[open] {
      border-color: var(--accent-color);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      background: #f9f9f9;
    }

    .faq-section summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--primary-color);
      padding: 0.8rem;
      outline: none;
      transition: var(--transition);
    }

    .faq-section summary:hover {
      color: var(--accent-color);
      background: #f5f5f5;
    }

    .faq-section p {
      margin-top: 1rem;
      padding: 0 1rem 1rem;
    }

    /* Breadcrumb Navigation */
    .breadcrumb {
      padding: 0.8rem 1rem;
      background: linear-gradient(to right, #f5f5f5, white);
      border-radius: var(--border-radius);
      margin-bottom: 2rem;
      font-size: 0.9rem;
    }

    .breadcrumb a {
      color: var(--secondary-color);
    }

    .breadcrumb a:hover {
      text-decoration: underline;
    }

    /* Problem Metadata */
    .problem-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin: 1.5rem 0;
      padding: 1rem;
      background: #f8f9fa;
      border-radius: var(--border-radius);
    }

    .meta-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9rem;
    }

    .meta-item .label {
      font-weight: 600;
      color: var(--meta-color);
    }

    /* Callout Boxes */
    .callout {
      padding: 1rem 1.5rem;
      margin: 1.5rem 0;
      border-radius: var(--border-radius);
      border-left: 4px solid;
    }

    .callout.tip {
      background-color: var(--callout-tip);
      border-color: var(--callout-tip-border);
    }

    .callout.note {
      background-color: var(--callout-note);
      border-color: var(--callout-note-border);
    }

    .callout.warning {
      background-color: var(--callout-warning);
      border-color: var(--callout-warning-border);
    }

    .callout.danger {
      background-color: var(--callout-danger);
      border-color: var(--callout-danger-border);
    }

    .callout strong {
      display: block;
      margin-bottom: 0.5rem;
      color: var(--primary-color);
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      main {
        margin: 1rem;
        padding: 1.5rem;
      }

      h1 {
        font-size: 1.7rem;
      }

      h2 {
        font-size: 1.4rem;
      }

      .problem-meta {
        flex-direction: column;
      }

      table {
        display: block;
        overflow-x: auto;
      }
    }

    @media (max-width: 480px) {
      main {
        padding: 1rem;
      }

      h1 {
        font-size: 1.5rem;
      }

      h2 {
        font-size: 1.2rem;
      }

      pre {
        padding: 0.8rem;
        font-size: 0.85rem;
      }

      .tab-button {
        padding: 0.6rem;
        font-size: 0.9rem;
      }

      .code-header {
        flex-direction: column;
        align-items: flex-start;
      }

      .code-copy {
        margin-top: 0.5rem;
      }
    }
  </style>
</head>

<body>
  <div id="header"></div>

  <main>
    <div class="breadcrumb">
      <a href="https://algopush.com">Home</a> &gt;
      <a href="https://algopush.com/Leetcode/leetcode.html">LeetCode</a> &gt;
      <span>3546. Equal Sum Grid Partition I</span>
    </div>

    <div class="problem-visual">
      <img src="https://algopush.com/Leetcode/Images/3546.png" alt="Grid partition visualization">
    </div>

    <h1>3546: Equal Sum Grid Partition I</h1>

    <div class="problem-meta">
      <div class="meta-item">
        <span class="label">Difficulty:</span>
        <span class="value">Medium</span>
      </div>
      <div class="meta-item">
        <span class="label">Topics:</span>
        <span class="value">Matrix, Prefix Sum, Array Manipulation</span>
      </div>
      <div class="meta-item">
        <span class="label">Companies:</span>
        <span class="value">Microsoft, Amazon, Oracle</span>
      </div>
    </div>

    <div class="callout tip">
      <strong>Key Insight:</strong> The solution requires calculating prefix sums efficiently and understanding parity
      conditions for equal partitioning.
    </div>

    <h2>Problem Statement</h2>
    <p>Given an m x n matrix of positive integers, determine if a single horizontal or vertical cut can split the grid
      into two non-empty parts with equal sums.</p>

    <h3>Example 1</h3>
    <pre><code>Input: grid = [[1,4],[2,3]]
Output: true
Explanation: Horizontal cut after first row creates two parts with sum 5 each</code></pre>

    <h3>Example 2</h3>
    <pre><code>Input: grid = [[1,3],[2,4]]
Output: false
Explanation: No valid cut exists</code></pre>

    <div class="callout note">
      <strong>Problem Link:</strong>
      <a href="https://leetcode.com/problems/equal-sum-grid-partition-i/" target="_blank" rel="noopener noreferrer">
        View on LeetCode ↗
      </a>
    </div>

    <hr />

    <h2>Approach 1: Brute Force Checking</h2>
    <p>Check all possible horizontal and vertical cuts by calculating partition sums directly.</p>

    <h3>Algorithm Steps</h3>
    <ol>
      <li>Calculate total sum of all elements</li>
      <li>Return false if total is odd</li>
      <li>Check every possible horizontal cut position</li>
      <li>Check every possible vertical cut position</li>
    </ol>

    <h3>Complexity Analysis</h3>
    <table>
      <thead>
        <tr>
          <th>Time Complexity</th>
          <th>Space Complexity</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>O(m²n + n²m)</td>
          <td>O(1)</td>
        </tr>
      </tbody>
    </table>

    <div class="code-container">
      <div class="code-header">
        <span class="code-filename">Brute Force Solution</span>
        <button class="code-copy">Copy Code</button>
      </div>
      <div class="code-tabs">
        <div class="tab-buttons">
          <button class="tab-button active" data-tab="cpp-brute">C++</button>
          <button class="tab-button" data-tab="java-brute">Java</button>
          <button class="tab-button" data-tab="python-brute">Python</button>
        </div>

        <!-- C++ Brute Force -->
        <div class="tab-content active" id="cpp-brute-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
<span class="code-token-keyword">public</span>:
    <span class="code-token-keyword">bool</span> <span class="code-token-function">canPartitionGrid</span>(vector&lt;vector&lt;<span class="code-token-keyword">int</span>&gt;&gt;& grid) {
        <span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span> total = 0;
        <span class="code-token-keyword">int</span> m = grid.<span class="code-token-function">size</span>(), n = grid[0].<span class="code-token-function">size</span>();
        
        <span class="code-token-keyword">for</span> (auto& row : grid)
            <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> num : row)
                total += num;
        
        <span class="code-token-keyword">if</span> (total % 2 != 0) <span class="code-token-keyword">return</span> false;
        <span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span> target = total / 2;
        
        <span class="code-token-comment">// Check horizontal cuts</span>
        <span class="code-token-keyword">if</span> (m > 1) {
            <span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span> upperSum = 0;
            <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i &lt; m-1; ++i) {
                <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> num : grid[i])
                    upperSum += num;
                <span class="code-token-keyword">if</span> (upperSum == target) <span class="code-token-keyword">return</span> true;
            }
        }
        
        <span class="code-token-comment">// Check vertical cuts</span>
        <span class="code-token-keyword">if</span> (n > 1) {
            <span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span> leftSum = 0;
            <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> j = 0; j &lt; n-1; ++j) {
                <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i &lt; m; ++i)
                    leftSum += grid[i][j];
                <span class="code-token-keyword">if</span> (leftSum == target) <span class="code-token-keyword">return</span> true;
            }
        }
        
        <span class="code-token-keyword">return</span> false;
    }
};</code></pre>
        </div>

        <!-- Java Brute Force -->
        <div class="tab-content" id="java-brute-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
    <span class="code-token-keyword">public</span> <span class="code-token-keyword">boolean</span> <span class="code-token-function">canPartitionGrid</span>(<span class="code-token-keyword">int</span>[][] grid) {
        <span class="code-token-keyword">long</span> total = 0;
        <span class="code-token-keyword">int</span> m = grid.length, n = grid[0].length;
        
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span>[] row : grid)
            <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> num : row)
                total += num;
        
        <span class="code-token-keyword">if</span> (total % 2 != 0) <span class="code-token-keyword">return</span> false;
        <span class="code-token-keyword">long</span> target = total / 2;
        
        <span class="code-token-comment">// Check horizontal cuts</span>
        <span class="code-token-keyword">if</span> (m > 1) {
            <span class="code-token-keyword">long</span> upperSum = 0;
            <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i &lt; m-1; ++i) {
                <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> num : grid[i])
                    upperSum += num;
                <span class="code-token-keyword">if</span> (upperSum == target) <span class="code-token-keyword">return</span> true;
            }
        }
        
        <span class="code-token-comment">// Check vertical cuts</span>
        <span class="code-token-keyword">if</span> (n > 1) {
            <span class="code-token-keyword">long</span> leftSum = 0;
            <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> j = 0; j &lt; n-1; ++j) {
                <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i &lt; m; ++i)
                    leftSum += grid[i][j];
                <span class="code-token-keyword">if</span> (leftSum == target) <span class="code-token-keyword">return</span> true;
            }
        }
        
        <span class="code-token-keyword">return</span> false;
    }
}</code></pre>
        </div>

        <!-- Python Brute Force -->
        <div class="tab-content" id="python-brute-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span>:
    <span class="code-token-keyword">def</span> <span class="code-token-function">canPartitionGrid</span>(self, grid: List[List[int]]) -> bool:
        total = sum(num <span class="code-token-keyword">for</span> row <span class="code-token-keyword">in</span> grid <span class="code-token-keyword">for</span> num <span class="code-token-keyword">in</span> row)
        <span class="code-token-keyword">if</span> total % 2 != 0: <span class="code-token-keyword">return</span> False
        target, m, n = total//2, len(grid), len(grid[0])
        
        <span class="code-token-comment"># Horizontal checks</span>
        <span class="code-token-keyword">if</span> m > 1:
            current = 0
            <span class="code-token-keyword">for</span> i <span class="code-token-keyword">in</span> range(m-1):
                current += sum(grid[i])
                <span class="code-token-keyword">if</span> current == target: <span class="code-token-keyword">return</span> True
        
        <span class="code-token-comment"># Vertical checks</span>
        <span class="code-token-keyword">if</span> n > 1:
            current = 0
            <span class="code-token-keyword">for</span> j <span class="code-token-keyword">in</span> range(n-1):
                current += sum(row[j] <span class="code-token-keyword">for</span> row <span class="code-token-keyword">in</span> grid)
                <span class="code-token-keyword">if</span> current == target: <span class="code-token-keyword">return</span> True
        
        <span class="code-token-keyword">return</span> False</code></pre>
        </div>
      </div>
      <div class="callout note">
        <strong>Use Case:</strong> Only suitable for small grids (m,n &lt; 50) due to quadratic complexity
      </div>
    </div>

    <hr />

    <h2>Approach 2: Original Prefix Sum</h2>
    <p>Initial implementation with separate sum calculations for rows and columns.</p>

    <h3>Algorithm Steps</h3>
    <ol>
      <li>Calculate total sum in first pass</li>
      <li>Compute row sums in second pass</li>
      <li>Compute column sums in third pass</li>
      <li>Check prefix sums for valid partitions</li>
    </ol>

    <h3>Complexity Analysis</h3>
    <table>
      <thead>
        <tr>
          <th>Time Complexity</th>
          <th>Space Complexity</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>O(3m*n)</td>
          <td>O(max(m,n))</td>
        </tr>
      </tbody>
    </table>

    <div class="code-container">
      <div class="code-header">
        <span class="code-filename">Original Solution</span>
        <button class="code-copy">Copy Code</button>
      </div>
      <div class="code-tabs">
        <div class="tab-buttons">
          <button class="tab-button active" data-tab="cpp-orig">C++</button>
          <button class="tab-button" data-tab="java-orig">Java</button>
          <button class="tab-button" data-tab="python-orig">Python</button>
        </div>

        <!-- C++ Original -->
        <div class="tab-content active" id="cpp-orig-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
<span class="code-token-keyword">public</span>:
    <span class="code-token-keyword">bool</span> <span class="code-token-function">canPartitionGrid</span>(vector&lt;vector&lt;<span class="code-token-keyword">int</span>&gt;&gt;& grid) {
        <span class="code-token-keyword">int</span> total = 0;
        <span class="code-token-keyword">for</span>(auto& row : grid) {
            <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> num : row) {
                total += num;
            }
        }
        
        <span class="code-token-keyword">if</span>(total % 2 != 0) <span class="code-token-keyword">return</span> false;
        <span class="code-token-keyword">int</span> target = total / 2;
        
        <span class="code-token-keyword">int</span> rowSum = 0;
        <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> i = 0; i &lt; grid.<span class="code-token-function">size</span>(); ++i) {
            <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> num : grid[i]) {
                rowSum += num;
            }
            <span class="code-token-keyword">if</span>(rowSum == target && i != grid.<span class="code-token-function">size</span>()-1) {
                <span class="code-token-keyword">return</span> true;
            }
        }
        
        <span class="code-token-keyword">int</span> n = grid[0].<span class="code-token-function">size</span>();
        vector&lt;<span class="code-token-keyword">int</span>&gt; <span class="code-token-function">colSums</span>(n, 0);
        <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> j = 0; j &lt; n; ++j) {
            <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> i = 0; i &lt; grid.<span class="code-token-function">size</span>(); ++i) {
                colSums[j] += grid[i][j];
            }
        }
        
        <span class="code-token-keyword">int</span> colPrefix = 0;
        <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> j = 0; j &lt; n; ++j) {
            colPrefix += colSums[j];
            <span class="code-token-keyword">if</span>(colPrefix == target && j != n-1) {
                <span class="code-token-keyword">return</span> true;
            }
        }
        
        <span class="code-token-keyword">return</span> false;
    }
};</code></pre>
        </div>

        <!-- Java Original -->
        <div class="tab-content" id="java-orig-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
    <span class="code-token-keyword">public</span> <span class="code-token-keyword">boolean</span> <span class="code-token-function">canPartitionGrid</span>(<span class="code-token-keyword">int</span>[][] grid) {
        <span class="code-token-keyword">int</span> total = 0;
        <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span>[] row : grid) {
            <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> num : row) {
                total += num;
            }
        }
        
        <span class="code-token-keyword">if</span>(total % 2 != 0) <span class="code-token-keyword">return</span> false;
        <span class="code-token-keyword">int</span> target = total / 2;
        
        <span class="code-token-keyword">int</span> rowSum = 0;
        <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> i = 0; i &lt; grid.length; i++) {
            <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> num : grid[i]) {
                rowSum += num;
            }
            <span class="code-token-keyword">if</span>(rowSum == target && i != grid.length-1) {
                <span class="code-token-keyword">return</span> true;
            }
        }
        
        <span class="code-token-keyword">int</span> n = grid[0].length;
        <span class="code-token-keyword">int</span>[] colSums = <span class="code-token-keyword">new</span> <span class="code-token-keyword">int</span>[n];
        <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> j = 0; j &lt; n; j++) {
            <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> i = 0; i &lt; grid.length; i++) {
                colSums[j] += grid[i][j];
            }
        }
        
        <span class="code-token-keyword">int</span> colPrefix = 0;
        <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> j = 0; j &lt; n; j++) {
            colPrefix += colSums[j];
            <span class="code-token-keyword">if</span>(colPrefix == target && j != n-1) {
                <span class="code-token-keyword">return</span> true;
            }
        }
        
        <span class="code-token-keyword">return</span> false;
    }
}</code></pre>
        </div>

        <!-- Python Original -->
        <div class="tab-content" id="python-orig-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span>:
    <span class="code-token-keyword">def</span> <span class="code-token-function">canPartitionGrid</span>(self, grid: List[List[int]]) -> bool:
        total = sum(num <span class="code-token-keyword">for</span> row <span class="code-token-keyword">in</span> grid <span class="code-token-keyword">for</span> num <span class="code-token-keyword">in</span> row)
        
        <span class="code-token-keyword">if</span> total % 2 != 0:
            <span class="code-token-keyword">return</span> False
        
        target = total // 2
        current = 0
        
        <span class="code-token-comment"># Check horizontal cuts</span>
        <span class="code-token-keyword">for</span> i <span class="code-token-keyword">in</span> range(len(grid)):
            current += sum(grid[i])
            <span class="code-token-keyword">if</span> current == target <span class="code-token-keyword">and</span> i != len(grid)-1:
                <span class="code-token-keyword">return</span> True
        
        <span class="code-token-comment"># Check vertical cuts</span>
        <span class="code-token-keyword">if</span> len(grid[0]) == 1:
            <span class="code-token-keyword">return</span> False
            
        col_sums = [sum(row[j] <span class="code-token-keyword">for</span> row <span class="code-token-keyword">in</span> grid) <span class="code-token-keyword">for</span> j <span class="code-token-keyword">in</span> range(len(grid[0]))]
        current_col = 0
        
        <span class="code-token-keyword">for</span> j <span class="code-token-keyword">in</span> range(len(col_sums)):
            current_col += col_sums[j]
            <span class="code-token-keyword">if</span> current_col == target <span class="code-token-keyword">and</span> j != len(col_sums)-1:
                <span class="code-token-keyword">return</span> True
        
        <span class="code-token-keyword">return</span> False</code></pre>
        </div>
      </div>
      <div class="callout note">
        <strong>Note:</strong> This approach uses three separate loops leading to higher constant factors
      </div>
    </div>

    <hr />

    <h2>Approach 3: Optimized Prefix Sum with Precomputation</h2>
    <p>Calculate total sum, row sums, and column sums in a single pass, then check prefix sums efficiently.</p>

    <h3>Algorithm Steps</h3>
    <ol>
      <li>Compute total sum, row sums, and column sums in one loop</li>
      <li>Return false if total is odd</li>
      <li>Check horizontal cuts using precomputed row sums</li>
      <li>Check vertical cuts using precomputed column sums</li>
    </ol>

    <h3>Complexity Analysis</h3>
    <table>
      <thead>
        <tr>
          <th>Time Complexity</th>
          <th>Space Complexity</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>O(m*n)</td>
          <td>O(m + n)</td>
        </tr>
      </tbody>
    </table>

    <div class="code-container">
      <div class="code-header">
        <span class="code-filename">Optimal Solution</span>
        <button class="code-copy">Copy Code</button>
      </div>
      <div class="code-tabs">
        <div class="tab-buttons">
          <button class="tab-button active" data-tab="cpp-sol">C++</button>
          <button class="tab-button" data-tab="java-sol">Java</button>
          <button class="tab-button" data-tab="python-sol">Python</button>
        </div>

        <!-- C++ Code -->
        <div class="tab-content active" id="cpp-sol-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
<span class="code-token-keyword">public</span>:
    <span class="code-token-keyword">bool</span> <span class="code-token-function">canPartitionGrid</span>(vector&lt;vector&lt;<span class="code-token-keyword">int</span>&gt;&gt;& grid) {
        <span class="code-token-keyword">int</span> m = grid.<span class="code-token-function">size</span>();
        <span class="code-token-keyword">if</span> (m == 0) <span class="code-token-keyword">return</span> false;
        <span class="code-token-keyword">int</span> n = grid[0].<span class="code-token-function">size</span>();
        <span class="code-token-keyword">if</span> (n == 0) <span class="code-token-keyword">return</span> false;
        
        <span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span> total = 0;
        vector&lt;<span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span>&gt; <span class="code-token-function">rowSums</span>(m, 0);
        vector&lt;<span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span>&gt; <span class="code-token-function">colSums</span>(n, 0);
        
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i &lt; m; ++i) {
            <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> j = 0; j &lt; n; ++j) {
                rowSums[i] += grid[i][j];
                colSums[j] += grid[i][j];
                total += grid[i][j];
            }
        }
        
        <span class="code-token-keyword">if</span> (total % 2 != 0) <span class="code-token-keyword">return</span> false;
        <span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span> target = total / 2;
        
        <span class="code-token-comment">// Check horizontal cuts</span>
        <span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span> rowPrefix = 0;
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i &lt; m; ++i) {
            rowPrefix += rowSums[i];
            <span class="code-token-keyword">if</span> (rowPrefix == target && i != m - 1) {
                <span class="code-token-keyword">return</span> true;
            }
        }
        
        <span class="code-token-comment">// Check vertical cuts</span>
        <span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span> colPrefix = 0;
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> j = 0; j &lt; n; ++j) {
            colPrefix += colSums[j];
            <span class="code-token-keyword">if</span> (colPrefix == target && j != n - 1) {
                <span class="code-token-keyword">return</span> true;
            }
        }
        
        <span class="code-token-keyword">return</span> false;
    }
};</code></pre>
        </div>

        <!-- Java Code -->
        <div class="tab-content" id="java-sol-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
    <span class="code-token-keyword">public</span> <span class="code-token-keyword">boolean</span> <span class="code-token-function">canPartitionGrid</span>(<span class="code-token-keyword">int</span>[][] grid) {
        <span class="code-token-keyword">int</span> m = grid.length;
        <span class="code-token-keyword">if</span> (m == 0) <span class="code-token-keyword">return</span> false;
        <span class="code-token-keyword">int</span> n = grid[0].length;
        <span class="code-token-keyword">if</span> (n == 0) <span class="code-token-keyword">return</span> false;
        
        <span class="code-token-keyword">long</span> total = 0;
        <span class="code-token-keyword">long</span>[] rowSums = <span class="code-token-keyword">new</span> <span class="code-token-keyword">long</span>[m];
        <span class="code-token-keyword">long</span>[] colSums = <span class="code-token-keyword">new</span> <span class="code-token-keyword">long</span>[n];
        
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i &lt; m; ++i) {
            <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> j = 0; j &lt; n; ++j) {
                rowSums[i] += grid[i][j];
                colSums[j] += grid[i][j];
                total += grid[i][j];
            }
        }
        
        <span class="code-token-keyword">if</span> (total % 2 != 0) <span class="code-token-keyword">return</span> false;
        <span class="code-token-keyword">long</span> target = total / 2;
        
        <span class="code-token-comment">// Check horizontal cuts</span>
        <span class="code-token-keyword">long</span> rowPrefix = 0;
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i &lt; m; ++i) {
            rowPrefix += rowSums[i];
            <span class="code-token-keyword">if</span> (rowPrefix == target && i != m - 1) {
                <span class="code-token-keyword">return</span> true;
            }
        }
        
        <span class="code-token-comment">// Check vertical cuts</span>
        <span class="code-token-keyword">long</span> colPrefix = 0;
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> j = 0; j &lt; n; ++j) {
            colPrefix += colSums[j];
            <span class="code-token-keyword">if</span> (colPrefix == target && j != n - 1) {
                <span class="code-token-keyword">return</span> true;
            }
        }
        
        <span class="code-token-keyword">return</span> false;
    }
}</code></pre>
        </div>

        <!-- Python Code -->
        <div class="tab-content" id="python-sol-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span>:
    <span class="code-token-keyword">def</span> <span class="code-token-function">canPartitionGrid</span>(self, grid: List[List[int]]) -> bool:
        <span class="code-token-keyword">if</span> <span class="code-token-keyword">not</span> grid <span class="code-token-keyword">or</span> <span class="code-token-keyword">not</span> grid[0]:
            <span class="code-token-keyword">return</span> False
        
        m, n = len(grid), len(grid[0])
        total = 0
        row_sums = [0] * m
        col_sums = [0] * n
        
        <span class="code-token-keyword">for</span> i <span class="code-token-keyword">in</span> range(m):
            <span class="code-token-keyword">for</span> j <span class="code-token-keyword">in</span> range(n):
                row_sums[i] += grid[i][j]
                col_sums[j] += grid[i][j]
                total += grid[i][j]
        
        <span class="code-token-keyword">if</span> total % 2 != 0:
            <span class="code-token-keyword">return</span> False
        target = total // 2
        
        <span class="code-token-comment"># Check horizontal cuts</span>
        current = 0
        <span class="code-token-keyword">for</span> i <span class="code-token-keyword">in</span> range(m):
            current += row_sums[i]
            <span class="code-token-keyword">if</span> current == target <span class="code-token-keyword">and</span> i != m - 1:
                <span class="code-token-keyword">return</span> True
        
        <span class="code-token-comment"># Check vertical cuts</span>
        current = 0
        <span class="code-token-keyword">for</span> j <span class="code-token-keyword">in</span> range(n):
            current += col_sums[j]
            <span class="code-token-keyword">if</span> current == target <span class="code-token-keyword">and</span> j != n - 1:
                <span class="code-token-keyword">return</span> True
        
        <span class="code-token-keyword">return</span> False</code></pre>
        </div>
      </div>
      <div class="callout note">
        <strong>Optimization Insight:</strong> Precompute row and column sums during total calculation to eliminate
        redundant loops. This reduces time complexity from O(3mn) to O(mn).
      </div>
    </div>

    <hr />

    <h2>Approach Comparison</h2>
    <table>
      <thead>
        <tr>
          <th>Approach</th>
          <th>Time</th>
          <th>Space</th>
          <th>Best For</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Brute Force</td>
          <td>O(m²n + n²m)</td>
          <td>O(1)</td>
          <td>Small grids (m,n &lt; 50)</td>
        </tr>
        <tr>
          <td>Original Prefix Sum</td>
          <td>O(3m*n)</td>
          <td>O(max(m,n))</td>
          <td>Medium grids</td>
        </tr>
        <tr>
          <td>Optimized Prefix Sum</td>
          <td>O(m*n)</td>
          <td>O(m + n)</td>
          <td>Large grids (m,n &gt; 10³)</td>
        </tr>
      </tbody>
    </table>

    <div class="callout warning">
      <strong>Important:</strong> The vertical cut check must be skipped for single-column grids to avoid invalid
      partitions.
    </div>

    <hr />

    <h2>Edge Case Analysis</h2>
    <h3>1. Single Row Grid</h3>
    <pre><code>Input: [[1,1]] → Output: true (vertical cut)</code></pre>

    <h3>2. Single Column Grid</h3>
    <pre><code>Input: [[2],[2]] → Output: true (horizontal cut)</code></pre>

    <h3>3. Minimum Valid Grid</h3>
    <pre><code>Input: [[1,1]] → Output: true</code></pre>

    <div class="callout danger">
      <strong>Pitfall:</strong> Always verify cuts don't create empty sections (check i != m-1 and j != n-1).
    </div>

    <hr />

    <h2>Frequently Asked Questions</h2>

    <div class="faq-section">
      <details>
        <summary>1. Why check total parity first?</summary>
        <p>Odd totals can't be split into two equal integer sums, providing early exit.</p>
      </details>

      <details>
        <summary>2. How to handle empty sections?</summary>
        <p>We ensure cuts aren't at grid edges using i != m-1 and j != n-1 checks.</p>
      </details>

      <details>
        <summary>3. Why process rows before columns?</summary>
        <p>Row checks often complete faster, enabling early returns for better performance.</p>
      </details>

      <details>
        <summary>4. How does column sum calculation work?</summary>
        <p>We transpose the grid and sum columns using list comprehensions for efficiency.</p>
      </details>

      <details>
        <summary>5. What's the maximum grid size handled?</summary>
        <p>Efficiently handles max constraints (m*n ≤ 1e5) with linear time complexity.</p>
      </details>

      <details>
        <summary>6. Can we optimize space further?</summary>
        <p>Yes by calculating column sums during iteration, but complicates code structure.</p>
      </details>

      <details>
        <summary>7. How to verify correct partitioning?</summary>
        <p>Verify sum(left/top) = sum(right/bottom) = total/2 with non-empty sections.</p>
      </details>

      <details>
        <summary>8. Why use prefix sums?</summary>
        <p>Allows O(1) sum comparison after each row/column instead of recalculating.</p>
      </details>

      <details>
        <summary>9. Handle varying row lengths?</summary>
        <p>Problem constraints ensure rectangular grids (all rows same length).</p>
      </details>

      <details>
        <summary>10. Real-world applications?</summary>
        <p>Data partitioning, load balancing, and resource allocation systems.</p>
      </details>
    </div>

    <div class="callout">
      <strong>Final Analysis:</strong> This problem demonstrates efficient matrix traversal techniques and mathematical
      optimization for partition problems. The solution leverages prefix sums and early termination checks to achieve
      optimal performance.
    </div>
  </main>

  <div id="footer"></div>

  <script>
    // Reuse the same JavaScript from previous post
    document.addEventListener('DOMContentLoaded', function () {
      // Tab functionality
      document.querySelectorAll('.code-tabs').forEach(container => {
        const tabButtons = container.querySelectorAll('.tab-button');
        const tabContents = container.querySelectorAll('.tab-content');

        // Initialize first tab
        if (!container.querySelector('.tab-button.active')) {
          tabButtons[0]?.classList.add('active');
          tabContents[0]?.classList.add('active');
        }

        tabButtons.forEach(button => {
          button.addEventListener('click', () => {
            const tabName = button.getAttribute('data-tab');
            tabButtons.forEach(btn => btn.classList.remove('active'));
            tabContents.forEach(content => content.classList.remove('active'));
            button.classList.add('active');
            container.querySelector(`#${tabName}-tab`).classList.add('active');
          });
        });
      });

      // Copy button functionality
      document.querySelectorAll('.code-copy').forEach(button => {
        button.addEventListener('click', () => {
          const activeTab = button.closest('.code-container').querySelector('.tab-content.active');
          const code = activeTab.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = 'Copied!';
            setTimeout(() => button.textContent = 'Copy Code', 2000);
          });
        });
      });

      // Load header and footer
      fetch("../components/header.html")
        .then((response) => response.text())
        .then((data) => {
          document.getElementById("header").innerHTML = data;
        });

      fetch("../components/footer.html")
        .then((response) => response.text())
        .then((data) => {
          document.getElementById("footer").innerHTML = data;
        });
    });
  </script>
</body>

</html>