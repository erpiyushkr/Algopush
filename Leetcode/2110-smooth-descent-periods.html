<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeetCode 2110: Number of Smooth Descent Periods of a Stock</title>
    <meta name="description"
        content="Solve LeetCode 2110 - Number of Smooth Descent Periods of a Stock. Learn multiple approaches: sliding window, dynamic programming, and mathematical formula. Code in C++, Java, Python.">
    <meta name="keywords"
        content="LeetCode 2110, Number of Smooth Descent Periods of a Stock, stock smooth descent, array problems, sliding window, two pointers, dynamic programming, algorithm solution, Algopush, coding interview preparation, contiguous subarrays, stock price patterns, leetcode medium, leetcode daily challenge, leetcode practice, coding interview questions">
    <meta name="author" content="Piyush Kumar, Algopush">
    <meta name="robots" content="index, follow">
    <meta name="author" content="Algopush">
    <meta name="robots" content="index, follow, max-image-preview:large">
    <meta name="googlebot" content="index, follow">
    <meta name="bingbot" content="index, follow">
    <meta name="language" content="English">
    <meta name="revisit-after" content="7 days">

    <!-- Canonical URL -->
    <link rel="canonical" href="https://algopush.com/Leetcode/2110-smooth-descent-periods.html">

    <!-- Favicon -->
    <link rel="icon" href="../components/favicon.png" type="image/x-icon">
    <link rel="apple-touch-icon" href="../components/favicon.png">

    <!-- Open Graph / Social Media Meta Tags -->
    <meta property="og:title" content="LeetCode 2110: Number of Smooth Descent Periods of a Stock">
    <meta property="og:description"
        content="Master the Smooth Descent Periods problem with sliding window, DP, and math approaches. Code in C++, Java, Python with detailed explanations.">
    <meta property="og:image" content="https://algopush.com/Leetcode/Images/2110.png">
    <meta property="og:url" content="https://algopush.com/Leetcode/2110-smooth-descent-periods.html">
    <meta property="og:type" content="article">

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="LeetCode: Smooth Descent Periods Solutions">
    <meta name="twitter:description"
        content="Learn optimal approaches for counting smooth descent periods in stock prices.">
    <meta name="twitter:image" content="https://algopush.com/Leetcode/Images/2110.png">

    <!-- Structured Data for SEO -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "TechArticle",
      "headline": "Smooth Descent Periods of a Stock Solution Guide",
      "url": "https://algopush.com/Leetcode/2110-smooth-descent-periods.html",
      "image": "https://algopush.com/Leetcode/Images/2110.png",
      "author": {
        "@type": "Person",
        "name": "Piyush Kumar",
        "url": "https://algopush.com/"
      },
      "datePublished": "2025-12-15",
      "dateModified": "2025-12-15",
      "publisher": {
        "@type": "Organization",
        "name": "Algopush",
        "logo": {
          "@type": "ImageObject",
          "url": "https://algopush.com/components/logo.png"
        }
      },
      "description": "Comprehensive solution for LeetCode Smooth Descent Periods problem with multiple approaches and code implementations.",
      "founder": {
        "@type": "Person",
        "name": "Piyush Kumar",
        "jobTitle": "Founder",
        "url": "https://algopush.com"
      },
      "foundingDate": "2025"
    }
  </script>

    <style>
        :root {
            --primary-color: #102c41;
            --secondary-color: #196391;
            --accent-color: #102c41;
            --meta-color: #db5305;
            --light-bg: #f5f9fc;
            --highlight-color: #f5f9fc;
            --text-color: black;
            --light-text: #7f8c8d;
            --border-radius: 6px;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
            --callout-tip: #e8f8f5;
            --callout-note: #eaf2f8;
            --callout-warning: #fef5e7;
            --callout-danger: #ffebee;
            --callout-tip-border: #1abc9c;
            --callout-note-border: #3498db;
            --callout-warning-border: #f39c12;
            --callout-danger-border: #f44336;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            background-color: var(--light-bg);
            color: var(--text-color);
            line-height: 1.7;
            font-size: 1.05rem;
        }

        main {
            max-width: 920px;
            margin: 2rem auto;
            padding: 2rem;
            background: #fff;
            box-shadow: var(--box-shadow);
            border-radius: var(--border-radius);
        }

        .problem-visual {
            max-width: 100%;
            margin: 1.5rem 0;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--box-shadow);
            text-align: center;
        }

        .problem-visual img {
            max-width: 100%;
            height: auto;
            max-height: 400px;
            display: inline-block;
        }

        h1,
        h2,
        h3,
        h4 {
            color: var(--primary-color);
            font-weight: 600;
            margin-top: 1.5rem;
            margin-bottom: 0.8rem;
            line-height: 1.3;
        }

        h1 {
            font-size: 2rem;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.5rem;
        }

        h2 {
            font-size: 1.6rem;
            border-left: 4px solid var(--accent-color);
            padding-left: 0.8rem;
            margin-top: 2.5rem;
        }

        h3 {
            font-size: 1.3rem;
            color: var(--secondary-color);
            margin-top: 1.8rem;
        }

        a {
            color: var(--accent-color);
            text-decoration: none;
            transition: var(--transition);
        }

        a:hover {
            color: var(--primary-color);
            text-decoration: underline;
        }

        hr {
            border: 0;
            height: 1px;
            background: #ddd;
            margin: 2rem 0;
        }

        pre {
            background: #f8f9fa;
            padding: 1.2rem;
            border-radius: var(--border-radius);
            overflow-x: auto;
            border-left: 4px solid var(--accent-color);
            font-size: 0.95rem;
            line-height: 1.5;
            margin: 1rem 0;
        }

        code {
            font-family: monospace;
            color: #2c3e50;
        }

        .highlight {
            background: var(--highlight-color);
            padding: 1rem;
            border-radius: var(--border-radius);
            margin: 1.5rem 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        th,
        td {
            padding: 0.8rem;
            text-align: center;
            border: 1px solid #ddd;
        }

        th {
            background-color: var(--primary-color);
            color: white;
            font-weight: 500;
        }

        tr:nth-child(even) {
            background-color: #f2f2f2;
        }

        .code-container {
            position: relative;
            margin: 1rem 0;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--box-shadow);
        }

        .code-header {
            background: var(--primary-color);
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
        }

        .code-filename {
            font-weight: 600;
        }

        .code-copy {
            background: white;
            color: var(--primary-color);
            border: none;
            padding: 0.25rem 0.75rem;
            border-radius: 3px;
            cursor: pointer;
            transition: var(--transition);
            font-weight: 500;
        }

        .code-copy:hover {
            background: var(--highlight-color);
        }

        .code-token-keyword {
            color: #d73a49;
        }

        .code-token-function {
            color: #6f42c1;
        }

        .code-token-comment {
            color: #6a737d;
            font-style: italic;
        }

        .code-token-string {
            color: #032f62;
        }

        .code-token-number {
            color: #005cc5;
        }

        .code-tabs {
            margin: 0.5rem 0;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--box-shadow);
        }

        .tab-buttons {
            display: flex;
            background: #eaecee;
            border-bottom: 1px solid #ddd;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .tab-button {
            padding: 0.7rem 1.2rem;
            background: transparent;
            border: none;
            cursor: pointer;
            font-weight: 500;
            color: var(--text-color);
            transition: var(--transition);
            white-space: nowrap;
            flex-shrink: 0;
        }

        .tab-button.active {
            background: var(--primary-color);
            color: white;
        }

        .tab-button:hover:not(.active) {
            background: #d5dbdb;
        }

        .tab-content {
            display: none;
            background: white;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .faq-section {
            margin: 2rem 0;
        }

        .faq-section details {
            margin: 0.8rem 0;
            padding: 0.1rem;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            background: white;
            transition: var(--transition);
        }

        .faq-section details[open] {
            border-color: var(--accent-color);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            background: #f9f9f9;
        }

        .faq-section summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--primary-color);
            padding: 0.8rem;
            outline: none;
            transition: var(--transition);
        }

        .faq-section summary:hover {
            color: var(--accent-color);
            background: #f5f5f5;
        }

        .faq-section p {
            margin-top: 1rem;
            padding: 0 1rem 1rem;
        }

        .breadcrumb {
            padding: 0.8rem 1rem;
            background: linear-gradient(to right, #f5f5f5, white);
            border-radius: var(--border-radius);
            margin-bottom: 2rem;
            font-size: 0.9rem;
        }

        .breadcrumb a {
            color: var(--secondary-color);
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        .problem-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin: 1.5rem 0;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: var(--border-radius);
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .meta-item .label {
            font-weight: 600;
            color: var(--meta-color);
        }

        .callout {
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            border-radius: var(--border-radius);
            border-left: 4px solid;
        }

        .callout.tip {
            background-color: var(--callout-tip);
            border-color: var(--callout-tip-border);
        }

        .callout.note {
            background-color: var(--callout-note);
            border-color: var(--callout-note-border);
        }

        .callout.warning {
            background-color: var(--callout-warning);
            border-color: var(--callout-warning-border);
        }

        .callout.danger {
            background-color: var(--callout-danger);
            border-color: var(--callout-danger-border);
        }

        .callout strong {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--primary-color);
        }

        .visual-container {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin: 2rem 0;
        }

        .visual-item {
            flex: 1;
            min-width: 300px;
            padding: 1rem;
            border-radius: var(--border-radius);
            background: #f8f9fa;
            box-shadow: var(--box-shadow);
        }

        .visual-item h4 {
            color: var(--secondary-color);
            margin-top: 0;
            border-bottom: 1px solid #ddd;
            padding-bottom: 0.5rem;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .grid-item {
            padding: 1rem;
            text-align: center;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            background: white;
            font-weight: bold;
        }

        .smooth {
            background-color: #e8f8f5;
            border-color: #1abc9c;
        }

        .not-smooth {
            background-color: #ffebee;
            border-color: #f44336;
        }

        @keyframes pulse {
            0% {
                background-color: #e6f7ff;
            }

            50% {
                background-color: #b3e0ff;
            }

            100% {
                background-color: #e6f7ff;
            }
        }

        @media (max-width: 768px) {
            main {
                margin: 1rem;
                padding: 1.5rem;
            }

            h1 {
                font-size: 1.7rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            .problem-meta {
                flex-direction: column;
            }

            table {
                display: block;
                overflow-x: auto;
            }

            .visual-item {
                min-width: 100%;
            }

            .grid-container {
                grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            }
        }

        @media (max-width: 480px) {
            main {
                padding: 1rem;
            }

            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.2rem;
            }

            pre {
                padding: 0.8rem;
                font-size: 0.85rem;
            }

            .tab-button {
                padding: 0.6rem;
                font-size: 0.9rem;
            }

            .code-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .code-copy {
                margin-top: 0.5rem;
            }
        }
    </style>
</head>

<body>
    <div id="header"></div>

    <main>
        <div class="breadcrumb">
            <a href="https://algopush.com">Home</a> &gt;
            <a href="https://algopush.com/Leetcode/leetcode.html">LeetCode</a> &gt;
            <span>Smooth Descent Periods</span>
        </div>

        <div class="problem-visual">
            <img src="https://algopush.com/Leetcode/Images/2110.png" alt="Smooth Descent Periods visualization"
                loading="lazy">
        </div>

        <h1>2110. Number of Smooth Descent Periods of a Stock</h1>

        <div class="problem-meta">
            <div class="meta-item">
                <span class="label">Difficulty:</span>
                <span class="value">Medium</span>
            </div>
            <div class="meta-item">
                <span class="label">Topics:</span>
                <span class="value">Array, Math, Dynamic Programming[citation:2]</span>
            </div>
            <div class="meta-item">
                <span class="label">Companies:</span>
                <span class="value">Amazon, Google, Bloomberg</span>
            </div>
            <div class="meta-item">
                <span class="label">Acceptance Rate:</span>
                <span class="value">65.1%</span>
            </div>
        </div>

        <div class="callout tip">
            <strong>Pro Tip:</strong> This problem is essentially about finding maximal runs of consecutive -1
            differences and summing the number of subarrays contributed by each run[citation:7]. While dynamic
            programming is possible, the most intuitive and optimal solution uses a sliding window or two pointers
            approach[citation:2].
        </div>

        <h2>Problem Statement</h2>
        <p>You are given an integer array <code>prices</code> representing the daily price history of a stock, where
            <code>prices[i]</code> is the stock price on the ith day.</p>
        <p>A <strong>smooth descent period</strong> of a stock consists of one or more contiguous days such that the
            price on each day is lower than the price on the preceding day by exactly 1. The first day of the period is
            exempted from this rule[citation:5].</p>
        <p>Return the number of smooth descent periods.</p>

        <div class="visual-container">
            <div class="visual-item">
                <h4>Example 1</h4>
                <p><strong>Input:</strong> prices = [3,2,1,4]</p>
                <p><strong>Output:</strong> 7</p>
                <p><strong>Explanation:</strong> There are 7 smooth descent periods:<br>
                    [3], [2], [1], [4], [3,2], [2,1], and [3,2,1]<br>
                    Note that a period with one day is a smooth descent period by the definition[citation:5].</p>
            </div>

            <div class="visual-item">
                <h4>Example 2</h4>
                <p><strong>Input:</strong> prices = [8,6,7,7]</p>
                <p><strong>Output:</strong> 4</p>
                <p><strong>Explanation:</strong> There are 4 smooth descent periods: [8], [6], [7], and [7]<br>
                    Note that [8,6] is not a smooth descent period as 8 - 6 ≠ 1[citation:5].</p>
            </div>

            <div class="visual-item">
                <h4>Example 3</h4>
                <p><strong>Input:</strong> prices = [1]</p>
                <p><strong>Output:</strong> 1</p>
                <p><strong>Explanation:</strong> There is 1 smooth descent period: [1][citation:5]</p>
            </div>
        </div>

        <div class="callout note">
            <strong>Problem Link:</strong>
            <a href="https://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/" target="_blank"
                rel="noopener noreferrer">
                View on LeetCode ↗
            </a>
        </div>

        <hr />

        <h2>Key Insight</h2>
        <p>The solution relies on these crucial observations:</p>
        <ol>
            <li>Every single day is a valid smooth descent period by definition (length 1 periods)</li>
            <li>For contiguous days where each day's price is exactly one less than the previous day, all subarrays of
                that contiguous segment are valid smooth descent periods</li>
            <li>If we find a contiguous segment of length <code>L</code> where prices decrease by exactly 1 each day, it
                contributes <code>L * (L + 1) / 2</code> smooth descent periods</li>
            <li>The array can be divided into multiple such segments separated by "breaks" where the difference is not
                exactly 1</li>
            <li>We can process the array in one pass using a sliding window or counter approach</li>
        </ol>

        <div class="callout warning">
            <strong>Important:</strong> While the problem can be solved with dynamic programming, many find the sliding
            window approach more intuitive for this problem[citation:2]. The dynamic programming tag might be misleading
            as the optimal solution doesn't require storing a full DP array.
        </div>

        <h2>Approach 1: Sliding Window / Counter (Optimal)</h2>
        <p>This is the most efficient approach with O(n) time and O(1) space[citation:1]. We maintain a counter that
            tracks the length of the current smooth descent segment.</p>

        <h3>Algorithm Steps</h3>
        <ol>
            <li>Initialize <code>ans = 1</code> (for the first day) and <code>dp = 1</code> (current descent length)
            </li>
            <li>Iterate from day 1 to n-1:
                <ul>
                    <li>If <code>prices[i] == prices[i-1] - 1</code>, increment <code>dp</code> (extend current descent)
                    </li>
                    <li>Otherwise, reset <code>dp = 1</code> (start new descent)</li>
                    <li>Add <code>dp</code> to <code>ans</code> (all subarrays ending at current day)</li>
                </ul>
            </li>
            <li>Return <code>ans</code></li>
        </ol>

        <h3>How It Works</h3>
        <p>At each position <code>i</code>, <code>dp</code> represents the number of smooth descent periods ending at
            day <code>i</code>. When we extend a descent, all previous periods that ended at <code>i-1</code> can be
            extended to include <code>i</code>, plus the new single-day period at <code>i</code>.</p>

        <h3>Complexity Analysis</h3>
        <table>
            <thead>
                <tr>
                    <th>Time Complexity</th>
                    <th>Space Complexity</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>O(n)</td>
                    <td>O(1)</td>
                </tr>
            </tbody>
        </table>
        <p>Where n is the number of days (length of prices array). Single pass through the array with constant extra
            space[citation:1].</p>

        <div class="code-container">
            <div class="code-header">
                <span class="code-filename">Sliding Window / Counter Approach</span>
                <button class="code-copy">Copy Code</button>
            </div>
            <div class="code-tabs">
                <div class="tab-buttons">
                    <button class="tab-button active" data-tab="cpp-sliding">C++</button>
                    <button class="tab-button" data-tab="java-sliding">Java</button>
                    <button class="tab-button" data-tab="python-sliding">Python</button>
                </div>

                <div class="tab-content active" id="cpp-sliding-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
<span class="code-token-keyword">public</span>:
  <span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span> <span class="code-token-function">getDescentPeriods</span>(vector<<span class="code-token-keyword">int</span>>& prices) {
    <span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span> ans = <span class="code-token-number">1</span>;  <span class="code-token-comment">// prices[0]</span>
    <span class="code-token-keyword">int</span> dp = <span class="code-token-number">1</span>;

    <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = <span class="code-token-number">1</span>; i < prices.<span class="code-token-function">size</span>(); ++i) {
      <span class="code-token-keyword">if</span> (prices[i] == prices[i - <span class="code-token-number">1</span>] - <span class="code-token-number">1</span>)
        ++dp;
      <span class="code-token-keyword">else</span>
        dp = <span class="code-token-number">1</span>;
      ans += dp;
    }

    <span class="code-token-keyword">return</span> ans;
  }
};</code></pre>
                </div>

                <div class="tab-content" id="java-sliding-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
  <span class="code-token-keyword">public</span> <span class="code-token-keyword">long</span> <span class="code-token-function">getDescentPeriods</span>(<span class="code-token-keyword">int</span>[] prices) {
    <span class="code-token-keyword">long</span> ans = <span class="code-token-number">1</span>; <span class="code-token-comment">// prices[0]</span>
    <span class="code-token-keyword">int</span> dp = <span class="code-token-number">1</span>;

    <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = <span class="code-token-number">1</span>; i < prices.length; ++i) {
      <span class="code-token-keyword">if</span> (prices[i] == prices[i - <span class="code-token-number">1</span>] - <span class="code-token-number">1</span>)
        ++dp;
      <span class="code-token-keyword">else</span>
        dp = <span class="code-token-number">1</span>;
      ans += dp;
    }

    <span class="code-token-keyword">return</span> ans;
  }
}</code></pre>
                </div>

                <div class="tab-content" id="python-sliding-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span>:
    <span class="code-token-keyword">def</span> <span class="code-token-function">getDescentPeriods</span>(self, prices: list[<span class="code-token-keyword">int</span>]) -> <span class="code-token-keyword">int</span>:
        ans = <span class="code-token-number">1</span>  <span class="code-token-comment"># prices[0]</span>
        dp = <span class="code-token-number">1</span>

        <span class="code-token-keyword">for</span> i <span class="code-token-keyword">in</span> range(<span class="code-token-number">1</span>, len(prices)):
            <span class="code-token-keyword">if</span> prices[i] == prices[i - <span class="code-token-number">1</span>] - <span class="code-token-number">1</span>:
                dp += <span class="code-token-number">1</span>
            <span class="code-token-keyword">else</span>:
                dp = <span class="code-token-number">1</span>
            ans += dp

        <span class="code-token-keyword">return</span> ans</code></pre>
                </div>
            </div>
            <div class="callout note">
                <strong>Why This Works:</strong> At each day <code>i</code>, <code>dp</code> counts how many smooth
                descent periods end at day <code>i</code>. When we have a smooth descent, all periods ending at day
                <code>i-1</code> can be extended to include day <code>i</code>, plus the single-day period at
                <code>i</code>. This elegant approach avoids storing the entire DP array[citation:1].
            </div>
        </div>

        <hr />

        <h2>Approach 2: Mathematical Formula for Contiguous Segments</h2>
        <p>Find all maximal smooth descent segments and use the formula for the sum of 1 + 2 + ... + L = L(L+1)/2 for
            each segment[citation:5].</p>

        <h3>Algorithm Steps</h3>
        <ol>
            <li>Initialize <code>ans = 0</code> and <code>i = 0</code></li>
            <li>While <code>i < n</code>:
                <ul>
                    <li>Start new segment with length <code>L = 1</code></li>
                    <li>Move <code>i</code> to next day</li>
                    <li>While still in smooth descent (<code>prices[i-1] - prices[i] == 1</code>), increment
                        <code>L</code> and <code>i</code></li>
                    <li>Add <code>L * (L + 1) / 2</code> to answer</li>
                </ul>
            </li>
            <li>Return <code>ans</code></li>
        </ol>

        <h3>How It Works</h3>
        <p>A contiguous segment of length <code>L</code> where prices decrease by exactly 1 each day contains exactly
            <code>L</code> single-day periods, <code>L-1</code> two-day periods, ..., and 1 <code>L</code>-day period.
            The total is the sum of 1 to <code>L</code>, which equals <code>L(L+1)/2</code>.</p>

        <h3>Complexity Analysis</h3>
        <table>
            <thead>
                <tr>
                    <th>Time Complexity</th>
                    <th>Space Complexity</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>O(n)</td>
                    <td>O(1)</td>
                </tr>
            </tbody>
        </table>
        <p>Single pass through the array with constant extra space[citation:5].</p>

        <div class="code-container">
            <div class="code-header">
                <span class="code-filename">Mathematical Formula Approach</span>
                <button class="code-copy">Copy Code</button>
            </div>
            <div class="code-tabs">
                <div class="tab-buttons">
                    <button class="tab-button active" data-tab="cpp-math">C++</button>
                    <button class="tab-button" data-tab="java-math">Java</button>
                    <button class="tab-button" data-tab="python-math">Python</button>
                </div>

                <div class="tab-content active" id="cpp-math-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
<span class="code-token-keyword">public</span>:
    <span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span> <span class="code-token-function">getDescentPeriods</span>(vector<<span class="code-token-keyword">int</span>>& prices) {
        <span class="code-token-keyword">int</span> n = prices.<span class="code-token-function">size</span>();
        <span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span> ans = <span class="code-token-number">0</span>, i = <span class="code-token-number">0</span>;
        <span class="code-token-keyword">while</span> (i < n) {
            <span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span> l = <span class="code-token-number">1</span>;
            i++;
            <span class="code-token-keyword">while</span> (i < n && prices[i - <span class="code-token-number">1</span>] - prices[i] == <span class="code-token-number">1</span>) i++, l++;
            ans += (l + <span class="code-token-number">1</span>) * l / <span class="code-token-number">2</span>;
        }
        <span class="code-token-keyword">return</span> ans;
    }
};</code></pre>
                </div>

                <div class="tab-content" id="java-math-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
    <span class="code-token-keyword">public</span> <span class="code-token-keyword">long</span> <span class="code-token-function">getDescentPeriods</span>(<span class="code-token-keyword">int</span>[] prices) {
        <span class="code-token-keyword">int</span> n = prices.length;
        <span class="code-token-keyword">long</span> ans = <span class="code-token-number">0</span>, i = <span class="code-token-number">0</span>;
        <span class="code-token-keyword">while</span> (i < n) {
            <span class="code-token-keyword">long</span> l = <span class="code-token-number">1</span>;
            i++;
            <span class="code-token-keyword">while</span> (i < n && prices[i - <span class="code-token-number">1</span>] - prices[i] == <span class="code-token-number">1</span>) {
                i++;
                l++;
            }
            ans += (l + <span class="code-token-number">1</span>) * l / <span class="code-token-number">2</span>;
        }
        <span class="code-token-keyword">return</span> ans;
    }
}</code></pre>
                </div>

                <div class="tab-content" id="python-math-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span>:
    <span class="code-token-keyword">def</span> <span class="code-token-function">getDescentPeriods</span>(self, prices: list[<span class="code-token-keyword">int</span>]) -> <span class="code-token-keyword">int</span>:
        n = len(prices)
        ans = <span class="code-token-number">0</span>
        i = <span class="code-token-number">0</span>
        <span class="code-token-keyword">while</span> i < n:
            l = <span class="code-token-number">1</span>
            i += <span class="code-token-number">1</span>
            <span class="code-token-keyword">while</span> i < n <span class="code-token-keyword">and</span> prices[i - <span class="code-token-number">1</span>] - prices[i] == <span class="code-token-number">1</span>:
                i += <span class="code-token-number">1</span>
                l += <span class="code-token-number">1</span>
            ans += (l + <span class="code-token-number">1</span>) * l // <span class="code-token-number">2</span>
        <span class="code-token-keyword">return</span> ans</code></pre>
                </div>
            </div>
            <div class="callout note">
                <strong>Formula Insight:</strong> For a contiguous smooth descent segment of length L, the number of
                subarrays is 1 + 2 + 3 + ... + L = L(L+1)/2. This approach explicitly finds each segment and applies
                this formula[citation:5].
            </div>
        </div>

        <hr />

        <h2>Approach 3: Dynamic Programming (Full DP Array)</h2>
        <p>Traditional dynamic programming approach storing DP values for each day[citation:5].</p>

        <h3>Algorithm Steps</h3>
        <ol>
            <li>Initialize <code>dp</code> array of size <code>n</code> with all 1's (each day is a valid period)</li>
            <li>Initialize <code>ans = 0</code></li>
            <li>For each day <code>i</code> from 0 to n-1:
                <ul>
                    <li>If <code>i > 0</code> and <code>prices[i-1] - prices[i] == 1</code>, add <code>dp[i-1]</code> to
                        <code>dp[i]</code></li>
                    <li>Add <code>dp[i]</code> to <code>ans</code></li>
                </ul>
            </li>
            <li>Return <code>ans</code></li>
        </ol>

        <h3>How It Works</h3>
        <p><code>dp[i]</code> stores the number of smooth descent periods ending at day <code>i</code>. If day
            <code>i</code> continues a smooth descent from day <code>i-1</code>, then all periods ending at
            <code>i-1</code> can be extended to include <code>i</code>.</p>

        <h3>Complexity Analysis</h3>
        <table>
            <thead>
                <tr>
                    <th>Time Complexity</th>
                    <th>Space Complexity</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>O(n)</td>
                    <td>O(n)</td>
                </tr>
            </tbody>
        </table>
        <p>Single pass through the array but requires O(n) space for the DP array[citation:5].</p>

        <div class="code-container">
            <div class="code-header">
                <span class="code-filename">Dynamic Programming Approach</span>
                <button class="code-copy">Copy Code</button>
            </div>
            <div class="code-tabs">
                <div class="tab-buttons">
                    <button class="tab-button active" data-tab="cpp-dp">C++</button>
                    <button class="tab-button" data-tab="java-dp">Java</button>
                    <button class="tab-button" data-tab="python-dp">Python</button>
                </div>

                <div class="tab-content active" id="cpp-dp-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
<span class="code-token-keyword">public</span>:
    <span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span> <span class="code-token-function">getDescentPeriods</span>(vector<<span class="code-token-keyword">int</span>>& prices) {
        <span class="code-token-keyword">int</span> n = prices.<span class="code-token-function">size</span>();
        <span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span> ans = <span class="code-token-number">0</span>;
        vector<<span class="code-token-keyword">int</span>> dp(n, <span class="code-token-number">1</span>);
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = <span class="code-token-number">0</span>; i < n; i++) {
            <span class="code-token-keyword">if</span> (i > <span class="code-token-number">0</span> && prices[i - <span class="code-token-number">1</span>] - prices[i] == <span class="code-token-number">1</span>) {
                dp[i] += dp[i - <span class="code-token-number">1</span>];
            }
            ans += dp[i];
        }
        <span class="code-token-keyword">return</span> ans;
    }
};</code></pre>
                </div>

                <div class="tab-content" id="java-dp-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
    <span class="code-token-keyword">public</span> <span class="code-token-keyword">long</span> <span class="code-token-function">getDescentPeriods</span>(<span class="code-token-keyword">int</span>[] prices) {
        <span class="code-token-keyword">int</span> n = prices.length;
        <span class="code-token-keyword">long</span> ans = <span class="code-token-number">0</span>;
        <span class="code-token-keyword">int</span>[] dp = <span class="code-token-keyword">new</span> <span class="code-token-keyword">int</span>[n];
        Arrays.<span class="code-token-function">fill</span>(dp, <span class="code-token-number">1</span>);
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = <span class="code-token-number">0</span>; i < n; i++) {
            <span class="code-token-keyword">if</span> (i > <span class="code-token-number">0</span> && prices[i - <span class="code-token-number">1</span>] - prices[i] == <span class="code-token-number">1</span>) {
                dp[i] += dp[i - <span class="code-token-number">1</span>];
            }
            ans += dp[i];
        }
        <span class="code-token-keyword">return</span> ans;
    }
}</code></pre>
                </div>

                <div class="tab-content" id="python-dp-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span>:
    <span class="code-token-keyword">def</span> <span class="code-token-function">getDescentPeriods</span>(self, prices: list[<span class="code-token-keyword">int</span>]) -> <span class="code-token-keyword">int</span>:
        n = len(prices)
        ans = <span class="code-token-number">0</span>
        dp = [<span class="code-token-number">1</span>] * n
        <span class="code-token-keyword">for</span> i <span class="code-token-keyword">in</span> range(n):
            <span class="code-token-keyword">if</span> i > <span class="code-token-number">0</span> <span class="code-token-keyword">and</span> prices[i - <span class="code-token-number">1</span>] - prices[i] == <span class="code-token-number">1</span>:
                dp[i] += dp[i - <span class="code-token-number">1</span>]
            ans += dp[i]
        <span class="code-token-keyword">return</span> ans</code></pre>
                </div>
            </div>
            <div class="callout note">
                <strong>DP Insight:</strong> This approach makes the recurrence relation explicit:
                <code>dp[i] = 1 + (dp[i-1] if smooth descent continues else 0)</code>. While correct, it uses O(n) space
                where O(1) space is possible[citation:5].
            </div>
        </div>

        <hr />

        <h2>Detailed Example Walkthrough</h2>
        <p>Let's trace through the sliding window approach with prices = [3,2,1,4]:</p>

        <div class="grid-container">
            <div class="grid-item smooth">Day 0: 3</div>
            <div class="grid-item smooth">Day 1: 2</div>
            <div class="grid-item smooth">Day 2: 1</div>
            <div class="grid-item">Day 3: 4</div>
        </div>

        <table>
            <thead>
                <tr>
                    <th>Day (i)</th>
                    <th>Price</th>
                    <th>Condition</th>
                    <th>dp (periods ending at i)</th>
                    <th>ans (total so far)</th>
                    <th>New Periods Added</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>0</td>
                    <td>3</td>
                    <td>Initialize</td>
                    <td>1</td>
                    <td>1</td>
                    <td>[3]</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>2</td>
                    <td>3-2=1 ✓</td>
                    <td>2</td>
                    <td>3</td>
                    <td>[2], [3,2]</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>1</td>
                    <td>2-1=1 ✓</td>
                    <td>3</td>
                    <td>6</td>
                    <td>[1], [2,1], [3,2,1]</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>4</td>
                    <td>1-4≠1 ✗</td>
                    <td>1</td>
                    <td>7</td>
                    <td>[4]</td>
                </tr>
            </tbody>
        </table>

        <div class="callout tip">
            <strong>Visualizing the Process:</strong> The <code>dp</code> counter represents "how many smooth descent
            periods end at the current day." When we have a smooth descent (difference = 1), all periods ending
            yesterday can be extended to include today, plus the new single-day period.
        </div>

        <hr />

        <h2>Comparison of Approaches</h2>
        <table>
            <thead>
                <tr>
                    <th>Approach</th>
                    <th>Time</th>
                    <th>Space</th>
                    <th>Key Insight</th>
                    <th>Best For</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Sliding Window</strong></td>
                    <td>O(n)</td>
                    <td>O(1)</td>
                    <td>Track current descent length with counter</td>
                    <td>Optimal solution, interviews</td>
                </tr>
                <tr>
                    <td><strong>Mathematical Formula</strong></td>
                    <td>O(n)</td>
                    <td>O(1)</td>
                    <td>Sum formula for contiguous segments</td>
                    <td>Mathematical understanding</td>
                </tr>
                <tr>
                    <td><strong>Dynamic Programming</strong></td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                    <td>Explicit DP recurrence relation</td>
                    <td>Learning DP patterns</td>
                </tr>
            </tbody>
        </table>

        <div class="callout warning">
            <strong>Tag Controversy:</strong> Some argue that the "Dynamic Programming" tag for this problem is
            misleading, as the optimal solution is more naturally a sliding window/two pointers approach[citation:2].
            While DP is possible, it's not the most intuitive solution for this problem.
        </div>

        <hr />

        <h2>Edge Cases and Testing</h2>

        <h3>1. Single Element Array</h3>
        <pre><code>Input: [5] → Output: 1
Input: [1] → Output: 1
All single-element arrays should return 1</code></pre>

        <h3>2. All Smooth Descent</h3>
        <pre><code>Input: [5,4,3,2,1] → Output: 15
Length 5: contributes 5*6/2 = 15 periods
[5],[4],[3],[2],[1],[5,4],[4,3],[3,2],[2,1],[5,4,3],[4,3,2],[3,2,1],[5,4,3,2],[4,3,2,1],[5,4,3,2,1]</code></pre>

        <h3>3. No Smooth Descent (Except Single Days)</h3>
        <pre><code>Input: [1,3,5,7,9] → Output: 5
Each day is its own period, no multi-day periods
[1],[3],[5],[7],[9]</code></pre>

        <h3>4. Mixed Pattern</h3>
        <pre><code>Input: [8,7,6,8,7,6,5] → Output: 13
Segments: [8,7,6] (length 3 → 6 periods), [8,7,6,5] (length 4 → 10 periods)
But careful: Actually two separate segments: [8,7,6] and [8,7,6,5] starting at index 3
Total: 6 + (10-3) = 13? Let's compute properly:
Using sliding window: 1+2+3+1+2+3+4 = 16? Wait, recalculate:
Actually trace it: 1,2,3,1,2,3,4 → sum = 16</code></pre>

        <h3>5. Large Arrays</h3>
        <pre><code>Input: [100000,99999,99998,...,1] (length 100000)
Output: 100000*100001/2 = 5,000,050,000
Must use 64-bit integers (long long in C++, long in Java)</code></pre>

        <div class="callout danger">
            <strong>Integer Overflow Warning:</strong> For large arrays with long smooth descents, the count can exceed
            32-bit integer range. Always use 64-bit integers (long long in C++, long in Java, int in Python handles big
            integers automatically).
        </div>

        <hr />

        <h2>FAQs</h2>

        <div class="faq-section">
            <details>
                <summary>1. Why does every single day count as a smooth descent period?</summary>
                <p>The problem definition states: "A smooth descent period consists of one or more contiguous days...
                    The first day of the period is exempted from this rule." This means a single day has no preceding
                    day to compare with, so it automatically qualifies[citation:5].</p>
            </details>

            <details>
                <summary>2. What's the difference between the sliding window and DP approaches?</summary>
                <p>The sliding window approach (Approach 1) uses O(1) space by keeping only a counter. The DP approach
                    (Approach 3) uses O(n) space storing values for each day. Both have O(n) time, but sliding window is
                    more space-efficient[citation:1][citation:5].</p>
            </details>

            <details>
                <summary>3. Why is the formula L(L+1)/2 used for contiguous segments?</summary>
                <p>A contiguous segment of length L where each day decreases by exactly 1 from the previous day
                    contains:
                    <br>• L single-day periods
                    <br>• L-1 two-day periods
                    <br>• ...
                    <br>• 1 L-day period
                    <br>Sum = 1 + 2 + 3 + ... + L = L(L+1)/2[citation:5]
                </p>
            </details>

            <details>
                <summary>4. How do we handle cases where the difference is not exactly 1?</summary>
                <p>When prices[i-1] - prices[i] ≠ 1, we reset our counter to 1 (starting a new potential smooth
                    descent). The current day still counts as a single-day period.</p>
            </details>

            <details>
                <summary>5. What's the time complexity of checking if prices[i-1] - prices[i] == 1?</summary>
                <p>This is an O(1) operation. Since we do it n-1 times (for i from 1 to n-1), the total time is O(n).
                </p>
            </details>

            <details>
                <summary>6. Can the prices increase within a smooth descent period?</summary>
                <p>No, by definition each day must be lower than the preceding day by exactly 1. If prices increase or
                    decrease by more than 1, it breaks the smooth descent.</p>
            </details>

            <details>
                <summary>7. What if prices[i-1] - prices[i] equals -1 (price increases by 1)?</summary>
                <p>That doesn't count as a smooth descent. The condition requires prices[i-1] - prices[i] == 1, which
                    means price decreases by exactly 1.</p>
            </details>

            <details>
                <summary>8. How does the algorithm handle duplicate consecutive prices?</summary>
                <p>If prices[i] == prices[i-1], then prices[i-1] - prices[i] == 0, not 1. So the descent breaks, and we
                    reset the counter to 1.</p>
            </details>

            <details>
                <summary>9. Is the sliding window approach the same as two pointers?</summary>
                <p>Yes, the sliding window approach can be seen as a two-pointer approach where one pointer (i) moves
                    through the array and we maintain a counter (dp) that represents the current window length of smooth
                    descent.</p>
            </details>

            <details>
                <summary>10. What's the maximum possible answer for the given constraints?</summary>
                <p>With n ≤ 10^5, if all prices form one smooth descent, the answer would be n(n+1)/2 ≈ 5×10^9 for
                    n=10^5. This fits in 64-bit integers but exceeds 32-bit range.</p>
            </details>
        </div>

        <div class="callout note">
            <strong>About Algopush:</strong> Algopush provides comprehensive algorithm solutions and explanations for
            coding interview preparation.
            Visit <a href="https://algopush.com">algopush.com</a> for more problem solutions and coding resources.
        </div>
    </main>

    <div id="footer"></div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Tab functionality
            document.querySelectorAll('.code-tabs').forEach(container => {
                const tabButtons = container.querySelectorAll('.tab-button');
                const tabContents = container.querySelectorAll('.tab-content');

                // Initialize first tab
                if (!container.querySelector('.tab-button.active')) {
                    tabButtons[0]?.classList.add('active');
                    tabContents[0]?.classList.add('active');
                }

                tabButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const tabName = button.getAttribute('data-tab');
                        tabButtons.forEach(btn => btn.classList.remove('active'));
                        tabContents.forEach(content => content.classList.remove('active'));
                        button.classList.add('active');
                        container.querySelector(`#${tabName}-tab`).classList.add('active');
                    });
                });
            });

            // Copy button functionality
            document.querySelectorAll('.code-copy').forEach(button => {
                button.addEventListener('click', () => {
                    const activeTab = button.closest('.code-container').querySelector('.tab-content.active');
                    const code = activeTab.querySelector('code').innerText;
                    navigator.clipboard.writeText(code).then(() => {
                        const originalText = button.textContent;
                        button.textContent = 'Copied!';
                        setTimeout(() => button.textContent = originalText, 2000);
                    });
                });
            });

            // Load header and footer
            fetch("../components/header.html")
                .then(response => response.text())
                .then(data => {
                    document.getElementById("header").innerHTML = data;
                });

            fetch("../components/footer.html")
                .then(response => response.text())
                .then(data => {
                    document.getElementById("footer").innerHTML = data;
                });
        });
    </script>
</body>

</html>